<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git指令集</title>
      <link href="/2026/01/26/Git/"/>
      <url>/2026/01/26/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Git是一个分布式版本控制系统，广泛用于软件开发和其他需要版本控制的项目中。Github和GitLab两个计算机领域绕不开的平台，都基于Git进行版本控制和协作开发。本文档将介绍一些常用的Git指令，帮助你更好地理解和使用Git。我们以Github为例进行说明。</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>在使用Git之前，我们需要进行一些基本的配置，主要包括设置用户名和邮箱地址。这些信息会被记录在每次提交中，用于标识提交的作者。</p><p>打开Git Bash，执行以下命令进行配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的邮箱地址&quot;</span><br></code></pre></td></tr></table></figure><p>如果去掉<code>--global</code>参数，则表示只对当前仓库进行配置。</p><p>如果想查看当前的配置信息，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure><h2 id="远程仓库关联"><a href="#远程仓库关联" class="headerlink" title="远程仓库关联"></a>远程仓库关联</h2><p>Github其实就是一个代码托管平台，用户可以在上面创建远程仓库来存储和管理代码。要将本地仓库与远程仓库关联，有以下两种方式：</p><ol><li><p><strong>git clone</strong>：用于从远程仓库克隆代码到本地。<br>例如我们在E:\Projects目录下打开Git Bash，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;远程仓库地址&gt;<br></code></pre></td></tr></table></figure></li></ol><p>得到的结果是Git会在E:\Projects目录下创建一个新的文件夹，文件夹名称与远程仓库名称相同，里面包含了远程仓库的所有代码和历史记录。结构图如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">当前目录<br>├─ repo/<br>│  ├─ .git/<br>│  ├─ README.md<br>│  └─ ...<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>git init</strong>：在本地创建一个新的Git仓库，然后手动关联到远程仓库。<br>例如我们在E:\Projects目录下打开Git Bash，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;initial commit&quot;</span><br>git remote add origin &lt;远程仓库地址&gt;      //关联远程仓库<br>git branch -M main         //把当前分支强制重命名为main<br>git push -u origin main<br></code></pre></td></tr></table></figure></li></ol><p>Git会在E:\Projects目录下创建一个.git文件夹，表示这是一个Git仓库。结构图如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">├─ 当前目录<br>│  ├─ .git/<br>│  ├─ README.md<br>│  └─ ...<br></code></pre></td></tr></table></figure><p><strong>注意以上两种方法均需要在远程仓库平台（如Github）上提前创建好远程仓库。</strong></p><h2 id="文件提交"><a href="#文件提交" class="headerlink" title="文件提交"></a>文件提交</h2><p>在掌握怎么提交文件之前，我们需要先了解Git的工作区、暂存区和本地仓库（版本库）三个概念：</p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>工作区是我们在电脑上看到的文件和文件夹的实际位置。我们在工作区进行文件的编辑、添加和删除等操作。</p><h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>暂存区是一个临时存储区域，用于保存我们准备提交到本地仓库的文件快照。当我们执行<code>git add</code>命令时，文件会被添加到暂存区。</p><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>本地仓库是我们<strong>电脑上</strong>存储版本历史记录的地方。当我们执行<code>git commit</code>命令时，暂存区的文件会被提交到本地仓库，形成一个新的版本，这个版本会有唯一的标识符且不可更改。</p><p>了解了这三个概念后，我们就可以在<code>.git</code>所在的目录下执行相关指令来提交文件了。</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol><li>**git add &lt;文件名&gt;**：将指定文件添加到暂存区。如果要添加所有修改过的文件，可以使用<code>git add .</code>。</li><li><strong>git status</strong>:查看哪些文件在暂存区中。不在暂存区代表未被git跟踪。</li><li><strong>git diff</strong>：查看<strong>工作区</strong>和<strong>暂存区</strong>之间的差异。</li><li>**git commit -m “提交信息”**：将暂存区的文件提交到本地仓库，并附上提交信息。</li><li><strong>git log</strong>：查看提交历史记录。</li><li><strong>git diff –cached</strong>:查看<strong>暂存区</strong>和<strong>本地仓库</strong>之间的差异。</li><li>**git push origin &lt;分支名&gt;**：将本地仓库的更改推送到远程仓库的指定分支上。</li></ol><h2 id="文件拉取"><a href="#文件拉取" class="headerlink" title="文件拉取"></a>文件拉取</h2><p>文件拉取有两种操作方式：</p><ol><li>**git pull origin &lt;分支名&gt;**：从远程仓库的指定分支拉取最新的更改并合并到当前分支。</li><li>**git fetch origin &lt;分支名&gt;**：从远程仓库获取最新的更改，但不进行合并。需要手动执行<code>git merge</code>命令将更改合并到当前分支。</li></ol><p>第二种方式的安全版：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout &lt;分支名&gt;        //切换到指定分支<br>git fetch origin &lt;分支名&gt;    //从远程仓库获取最新的更改<br>git diff origin/&lt;分支名&gt;   //查看远程分支和本地分支的差异<br>git merge origin/&lt;分支名&gt;  //将远程分支的更改合并到当前分支<br></code></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是Git的一个重要特性，允许我们在同一个仓库中并行开发不同的功能或修复不同的bug。常用的分支管理指令如下：</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout -b &lt;分支名&gt;   //创建并切换到新分支<br>git push -u origin &lt;分支名&gt;  //将新分支推送到远程仓库并关联<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch &lt;分支名&gt;        //只创建新分支<br>git push -u origin &lt;分支名&gt;  //将新分支推送到远程仓库并关联<br></code></pre></td></tr></table></figure><ul><li><p>这里分支名常用feature-xxx（新功能）、bugfix-xxx（修复bug）、hotfix-xxx（紧急修复）等命名规范。</p></li><li><p>创建的分支自动继承当前分支的代码和历史记录。</p></li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout &lt;分支名&gt;      //切换到指定分支<br></code></pre></td></tr></table></figure><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch                 //查看本地分支<br>git branch -r              //查看远程分支<br>git branch -a              //查看所有分支<br></code></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout &lt;目标分支&gt;     //切换到想要的当前分支<br>git merge &lt;源分支&gt;         //将源分支合并到当前分支(源分支是本地分支)<br>或者<br>git fetch origin &lt;源分支&gt;    //从远程仓库获取最新的更改<br>git merge origin/&lt;源分支&gt;  //将远程分支合并到当前分支<br></code></pre></td></tr></table></figure><p>当没有冲突时，Git会自动完成合并操作，然后执行add和commit操作。如果有冲突，Git会提示你手动解决冲突，解决后你需要手动执行add和commit操作。</p><p><strong>这里特别说明一下</strong>：<code>origin/&lt;源分支&gt;</code>代表的是本地记录的<code>远程分支快照</code>,不是远程仓库本身，而是你上次fetch&#x2F;pull时，Git在本地保存的一个远程分支指针。因此为了确保合并的是最新的远程状态，建议先执行<code>git fetch origin &lt;源分支&gt;</code>命令。</p><p>不难看出，<code>merge</code>操作实际上是将两个分支的代码进行整合，生成一个新的提交记录。并且这一行为发生在<code>本地仓库</code>中。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git branch -d &lt;分支名&gt;      //删除本地分支<br>git push origin --delete &lt;分支名&gt; //删除远程分支<br></code></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log</code>命令用于查看提交历史记录，在文件提交模块有提到过，这里补充一个常用的参数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --oneline        //以简洁的单行格式显示提交历史<br></code></pre></td></tr></table></figure><p><code>git log</code>命令还有很多其他参数，可以根据需要现学现用，这里就不过度展开了。</p><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p><code>git blame &lt;文件名&gt;</code>命令用于查看文件的每一行最后一次修改的提交记录，包括提交者、提交时间和提交信息等。这个命令对于追踪代码的变更历史非常有用。</p><p>同样<code>git blame</code>命令也有很多参数，可以使用<code>git blame --help</code>命令查看详细的帮助信息。</p><h2 id="恢复和回退"><a href="#恢复和回退" class="headerlink" title="恢复和回退"></a>恢复和回退</h2><p>在使用Git的过程中，有时我们可能需要恢复文件到某个特定的状态。例如你写一个.py文件，写着写着红温了，文件改废了，但你又不知道改了哪里，这时候你就非常想回到上一次的提交重新来过。Git提供了多种方式来实现文件的恢复和回退，下面介绍几种常用的方法。</p><p><strong>重中之重</strong>：恢复和回退一定要在操作之前知道后果是什么，否则你是真的欲哭无泪啊！</p><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout &lt;commit&gt; -- &lt;文件名&gt;    //将工作区的文件恢复到&lt;commit&gt;提交的状态,同时自动add到暂存区<br></code></pre></td></tr></table></figure><p>这个命令会将指定文件恢复到上一次提交的状态，丢弃工作区中的所有修改。注意，这个操作是不可逆的，一旦执行，工作区中的修改将无法找回。</p><p><strong>易踩的坑</strong>: 如果去掉文件名，执行<code>git checkout &lt;commit&gt;</code>会把你的所有工作区的文件恢复到指定提交时的状态，但是此时，你的<code>HEAD</code>指针会被移动到该提交上，处于<strong>分离头指针</strong>状态。如果你在这个状态下进行新的提交，这些提交将不会属于任何分支，容易导致丢失。此时你执行<code>git checkout &lt;分支名&gt;</code>可以回到正常状态，但是这也会导致工作区的文件回到该分支的最新状态,即<code>checkout</code>之前的状态。所以，这一操作一般用来<strong>看</strong>历史，而不是<strong>改</strong>历史.</p><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><h4 id="–soft"><a href="#–soft" class="headerlink" title="–soft"></a>–soft</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --soft &lt;commit&gt;    //将当前分支的HEAD指针移动到&lt;commit&gt;提交,保留暂存区和工作区的修改<br></code></pre></td></tr></table></figure><p>用大白话说就是<code>add</code>还在，<code>commit</code>没了。<br>常常用在你想修改提交说明的时候。</p><h4 id="–mixed-默认"><a href="#–mixed-默认" class="headerlink" title="–mixed (默认)"></a>–mixed (默认)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --mixed &lt;commit&gt;    //将当前分支的HEAD指针移动到&lt;commit&gt;提交,保留工作区的修改,清空暂存区<br></code></pre></td></tr></table></figure><p>用大白话说就是<code>add</code>没了，<code>commit</code>没了。<br>常常用在你想重新选择要提交的文件的时候。</p><h4 id="–hard"><a href="#–hard" class="headerlink" title="–hard"></a>–hard</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard &lt;commit&gt;    //将当前分支的HEAD指针移动到&lt;commit&gt;提交,清空暂存区和工作区的修改<br></code></pre></td></tr></table></figure><p>用大白话说就是<code>add</code>没了，<code>commit</code>没了，工作区也没了。<br>常常用在你这次改动彻底废了，想回到某个提交重新开始的时候。</p><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p>git revert命令用于撤销某个提交的更改，但不会删除该提交记录。相反，它会创建一个新的提交，内容是对指定提交的反向更改。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git revert &lt;commit&gt;    //撤销&lt;commit&gt;提交的更改，在本地仓库生成一个新的提交<br></code></pre></td></tr></table></figure><p>常常用在你已经将更改推送到<strong>远程仓库</strong>，但又想撤销某个提交的情况下。因为它不会修改提交历史，所以不会影响其他协作者的工作。</p><p>你可以理解为在团队协作过程中不能轻易修改远程仓库的历史提交记录。</p><h3 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h3><p>reflog是Git的一个强大功能，用于记录HEAD指针的移动历史。可以说是我们在误操作后找回丢失提交的最后一道防线。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reflog    //查看HEAD指针的移动历史<br>git reset --hard &lt;reflog条目&gt;    //将当前分支的HEAD指针移动到指定的reflog条目<br></code></pre></td></tr></table></figure><p>reflog条目通常以<code>HEAD@&#123;n&#125;</code>的形式表示，其中<code>n</code>是一个整数，表示从当前HEAD位置向后数的第n次移动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文档介绍了Git的基本概念和常用指令，包括配置、远程仓库关联、文件提交、文件拉取、分支管理、查看提交历史以及恢复和回退等内容。掌握这些指令将帮助你更有效地使用Git进行版本控制和协作开发。<br>纸上得来终觉浅，绝知此事要躬行。希望大家在实际应用中学习Git，而不是看着Blog纸上谈兵。<br>Git功能强大，本文档只是冰山一角，建议在实际使用中不断学习和探索更多高级功能。祝你在使用Git的旅程中一切顺利！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://git-scm.com/doc">Git官方文档</a></li><li><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程 Git 教程</a></li><li><a href="https://git-scm.com/book/zh/v2">Pro Git 电子书</a></li><li><a href="https://learngitbranching.js.org/?locale=zh_CN">可视化理解 Git</a></li></ul><h2 id="Lirics-Sharing"><a href="#Lirics-Sharing" class="headerlink" title="Lirics Sharing"></a>Lirics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">是不是我能给的没他多<br>是否再绚烂的星河<br>天亮都要失色<br>听说你为他做的<br>件件是我 曾经求而不得<br>我够不着的烟火<br>偏偏降落 在别人窗口<br>那晚的风<br>吹到今天都还未凉透<br>才松开手<br>你却已握紧别的温柔<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P6课上</title>
      <link href="/2026/01/23/P6%E8%AF%BE%E4%B8%8A/"/>
      <url>/2026/01/23/P6%E8%AF%BE%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><strong>写在前面</strong>：P6其实是P5<strong>plus</strong>,依然是三类：<code>计算类</code>，<code>跳转类</code>，<code>访存类</code>。只是计算类一般会涉及对MDU的操作，访存类不能在DM进行计算(因为DM没有了…)。很抱歉这次只做了两道题，第三题看题时间被助教问答占掉了(不嘻嘻)。如果哪些方法写的不太详尽可以参考P5的<a href="https://cordial-kid.github.io/2026/01/21/P5%E8%AF%BE%E4%B8%8A/">这篇博客</a>，大同小异</p><h2 id="MYGO"><a href="#MYGO" class="headerlink" title="MYGO"></a>MYGO</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pattern_value(x) = 4位x的前导0个数 * 2 + 4位x中1的个数</span><br><span class="line">chain(x) = 32位二进制数分成8组，每组的pattern_value(x) * (组数 + 1) 组数从低位开始(0,1,2,3,4,5,6,7).</span><br><span class="line">A = chain(GPR(rs))</span><br><span class="line">B = chain(GPR(rt))</span><br><span class="line">if (A &gt; B) &#123;</span><br><span class="line">    hi = GPR[rs]</span><br><span class="line">    lo = GPR[rt]</span><br><span class="line">&#125;</span><br><span class="line">else if(A &lt; B) &#123;</span><br><span class="line">    hi = GPR[rt];</span><br><span class="line">    lo = GPR[rs];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    hi = GPR[rs] ^ GPR[rt];</span><br><span class="line">    lo = GPR[rs] ^ GPR[rt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYGO当作乘除指令来计算，延迟5个周期。</span><br></pre></td></tr></table></figure><p>这个乘除槽类计算指令肯定主体要在MDU模块内实现，我的建议是A，B的计算使用组合逻辑，hi，lo的赋值使用时序逻辑。组合逻辑计算别发怵，我敢打赌要是程序设计出这个逻辑看到这里的各位没有一个怕的，所以大胆上手就行。时序逻辑只要按照之前的判断方式添加就好，别忘了Start信号下cnt的修改就行。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (MDUOp == `MDU_MYGO) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (A &gt; B) <span class="keyword">begin</span></span><br><span class="line">        HIreg &lt;= GPT[rs];</span><br><span class="line">        LOreg &lt;= GPR[rt];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Stall模块跟mult一致即可。</p><h2 id="MBL"><a href="#MBL" class="headerlink" title="MBL"></a>MBL</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tmpA = IMM_BEQ(IMM指令跳转的数值)</span><br><span class="line">tmpB = GPR[rs] + GPR[rt]</span><br><span class="line">GPR[31] = PC + 8;</span><br><span class="line">if rs == rt &#123;</span><br><span class="line">    PC = tmpA;</span><br><span class="line">&#125;</span><br><span class="line">else if (rs[0] == rt[0]) &#123;</span><br><span class="line">    PC = &#123;tmpB[31:0],2&#x27;b0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这道题真的是坑点满满！！！</strong></p><ul><li>我们很容易先入为主地把<code>rs == rt</code>理解为<code>GPR[rs] == GPR[rt]</code>,恭喜你，你将收获莫名其妙的PC。</li><li>在D级我们一定会用到GPR[rs] 和 GPR[rt] 吗？如果我们直接按照之前的<code>rs_Tuse = 0</code>,<code>rt_Tuse = 0</code>来写，那么恭喜你，喜提TLE。</li></ul><p>注意到以上两点这道题也就迎刃而解了。在CMP新增<code>rs</code>,<code>rt</code>输入端口完成比较,新增输出端口<code>Judge</code>辅助判断跳转类型，NPC当然要增加<code>Judge</code>这个输入来计算新地址。</p><p>对于Stall，我们判断的条件是<code>(D_beq | D_jr | D_jalr | D_bne | (D_mbl &amp;&amp; Beq_jump == 1 &amp;&amp; Judge == 0)) ? 3&#39;d0 :</code>,即只在rs[0] &#x3D;&#x3D; rt[0]的条件下才需要GPR[rs]和GPR[rt]。这就解决了TLE问题。</p><h2 id="LBO"><a href="#LBO" class="headerlink" title="LBO"></a>LBO</h2><p>这里希望路过好心人可以告诉笔者一下题目，共同给学弟学妹一个完整的magicbook(bushi)，谢谢谢谢。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>P6其实和P5差不多，放宽心，前两到题肯定难不倒你，加油哦。再向好心人求一下<code>LBO</code>指令。</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">我也很想他 我们都一样</span><br><span class="line">在他的身上 曾找到翅膀</span><br><span class="line">只是那时的他 是因为你</span><br><span class="line">他开始飞翔</span><br><span class="line">我也很想他，在某个地方</span><br><span class="line">我少了尴尬 你少了肩膀</span><br><span class="line">而夏天还是那么短</span><br><span class="line">思念却很长</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P6课下</title>
      <link href="/2026/01/23/P6%E8%AF%BE%E4%B8%8B/"/>
      <url>/2026/01/23/P6%E8%AF%BE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>p6和P5的整体思路一样，区别在于P6将IM和DM模块放在了外部（课程组写好了代码），从而使得CPU更加纯粹，贴合实际。同时P6新增了乘除槽指令，由于乘除槽指令执行周期较长，因此我们在阻塞等方面要加以注意。废话不多说，我们开始吧。</p><h2 id="IFU-PC"><a href="#IFU-PC" class="headerlink" title="IFU -&gt; PC"></a>IFU -&gt; PC</h2><p>在P6实验中，IM外置，因此在P5的基础上，我们要删掉这部分，保留PC的同时在顶层模块mips新增接口与外置DM信息交换：<br><code>input [31:0] i_inst_rdata,      //F级PC对应的32位指令</code><br><code>output [31:0] i_inst_addr,      //F级PC</code></p><h2 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h2><p>P6新增指令<code>BNE</code>,需要在D_CMP模块完成比较。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> Beq_jump = (CMPOp == `CMP_BEQ &amp;&amp; RS_Data == RT_Data) ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                  (CMPOp == `CMP_BNE &amp;&amp; RS_Data != RT_Data) ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                  <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h2 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h2><p>P6不需要<code>$display(&quot;%d@%h: $%d &lt;= %h&quot;,$time,PC,A3,WD);</code></p><h2 id="def"><a href="#def" class="headerlink" title="def"></a>def</h2><p>这个模块其实本来没什么好说的，只要新增指令需要用到的变量我们在这里定义即可。在这里值得说明的是，虽然P6指令极多，但是笔者权衡之后依然采用每条指令独立考量的方式，没有像主流思路一样对指令进行分类。两种方式各有利弊，这里只能仁者见仁，智者见智了，举个例子。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> GRFA3Sel = (cal_r | jalr | mf) ? `GRFA3rd :</span><br><span class="line">                (cal_i | load | mfc0) ? `GRFA3rt : </span><br><span class="line">                (jal) ? `GRFA331 : `GRFA30;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> GRFA3Sel = (Add|Sub|Sll|Jalr|_And|_Or|Slt|Sltu|Mfhi|Mflo) ? `GRFA3rd :</span><br><span class="line">                  (Ori | Lw | Lui | Addi | Andi | Lh | Lb) ? `GRFA3rt :</span><br><span class="line">                  (Jal) ? `GRFA331 :</span><br><span class="line">                  `GRFA30;</span><br></pre></td></tr></table></figure><p>显然，第二段代码要比第一段代码冗杂的多，这是我采用的写法的缺点。但是你也很容易发现，第一种写法将分类和不分类杂糅了起来，导致在coding时极度混乱，容易出错；而第二段代码因为是每条指令独立考虑的，也就不存在这个问题了。个人不太喜欢这种易错感觉，当然大家如何架构还是看自己心意🫡。</p><h2 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h2><p>P6对ALU的改动就是增加了新的指令的计算方式<code>and,slt,sltu</code>。</p><h2 id="E-MDU"><a href="#E-MDU" class="headerlink" title="E_MDU"></a>E_MDU</h2><p>乘除槽的实现是P6的重点和难点。我们要实现8条乘除法相关指令：<code>mult</code> <code>multu</code> <code>div</code> <code>divu</code> <code>mthi</code> <code>mtlo</code> <code>mfhi</code> <code>mflo</code>，前4条指令是计算乘除法，并将结果存入HI，LO两个寄存器中，后4条指令是对HI和LO的读写。<br>我们把MDU模块当作特殊的ALU，对于<strong>前四条指令</strong>，MDU要执行很多个周期并且不需要输出计算结果，只要在时钟上升沿时将计算结果存入HI，LO寄存器即可。对于<code>mfhi,mflo</code>则需要正常输出。对于<code>mthi,mtlo</code>，在时钟上升沿时写入对应寄存器即可，只需要<strong>执行一个周期</strong>。<br>代码如下：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        HIreg &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">        LOreg &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">        cnt &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (MDUOp == `MDU_MULT) <span class="keyword">begin</span></span><br><span class="line">            &#123;HIreg,LOreg&#125; &lt;= <span class="built_in">$signed</span>(A) * <span class="built_in">$signed</span>(B);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (MDUOp == `MDU_MULTU) <span class="keyword">begin</span></span><br><span class="line">            &#123;HIreg,LOreg&#125; &lt;= A * B;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (MDUOp == `MDU_DIV) <span class="keyword">begin</span></span><br><span class="line">            HIreg &lt;= <span class="built_in">$signed</span>(A) % <span class="built_in">$signed</span>(B);</span><br><span class="line">            LOreg &lt;= <span class="built_in">$signed</span>(A) / <span class="built_in">$signed</span>(B); </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (MDUOp == `MDU_DIVU) <span class="keyword">begin</span></span><br><span class="line">            HIreg &lt;= A % B;</span><br><span class="line">            LOreg &lt;= A / B;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (MDUOp == `MDU_MTHI) <span class="keyword">begin</span></span><br><span class="line">            HIreg &lt;= A;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (MDUOp == `MDU_MTLO) <span class="keyword">begin</span></span><br><span class="line">            LOreg &lt;= A;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> MDUC = (MDUOp == `MDU_MFHI) ? HIreg :</span><br><span class="line">              (MDUOp == `MDU_MFLO) ? LOreg :</span><br><span class="line">              <span class="number">32&#x27;d0</span>;</span><br></pre></td></tr></table></figure><p>注：以下提到的乘除法计算均为<code>mult,multu,div,divu</code>。<br>关于阻塞，之前我们提到了乘除法的计算周期较长，为了不因为乘除法计算的存在而拉低CPU的最短时钟周期，我们引入了MDU。因此当MDU模块正在计算时，所有不进入MDU的指令都可以正常流水，这也就导致了MDU的阻塞与自身息息相关。当MDU执行乘除法计算时，</p><ol><li>出现了<code>mfhi,mflo</code>,将指令阻塞在D级。</li><li>出现了<code>mult,multu,div,divu</code>,直接终止运算因为接下来要覆盖</li><li>出现了<code>mthi,mtlo</code>,将指令阻塞在D级。</li></ol><p>当然课程组为了方便我们设计给了我们一些提示：</p><ol><li>当E级指令是<code>mult multu div divu</code>时，CTRL模块需要输出1个周期的1位<strong>start</strong>信号，表示乘除法计算开始；</li><li>当start信号结束后，如果之前的计算指令是<code>mult multu</code>指令，MDU模块需要连续输出<strong>5</strong>个周期的<strong>busy</strong>信号，表示正在计算HI寄存器和LO寄存器的值；如果之前的计算指令是<code>div divu</code>指令，则需要连续输出<strong>10</strong>个周期的<strong>busy</strong>信号；</li><li>当start信号或busy信号为1时，不进入MDU模块的指令正常流水，要进入MDU模块的所有指令均阻塞在D级；</li><li>为了降低实现难度，保证MDU模块在进行乘除法计算时只会出现<code>mfhi mflo</code>两种乘除法指令。</li></ol><p>也就是说，对于乘除法计算指令涉及的阻塞，我们只要无脑阻塞在D级即可。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CTRL</span></span><br><span class="line"><span class="keyword">assign</span> Start = Mult | Multu | Div | Divu;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E_MDU</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">if</span> (Start) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (MDUOp == `MDU_DIV || MDUOp == `MDU_DIVU) <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= <span class="number">4&#x27;d10</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(MDUOp == `MDU_MULT || MDUOp == `MDU_MULTU) <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= <span class="number">4&#x27;d5</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">4&#x27;d0</span>) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> MDUC = (MDUOp == `MDU_MFHI) ? HIreg :</span><br><span class="line">                  (MDUOp == `MDU_MFLO) ? LOreg :</span><br><span class="line">                  <span class="number">32&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> Busy = (cnt != <span class="number">4&#x27;d0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stall</span></span><br><span class="line"><span class="keyword">assign</span> E_stall_MDU = ((D_mult | D_multu | D_div | D_divu | D_mfhi | D_mflo | D_mthi | D_mtlo) &amp;&amp; (Start | Busy));</span><br></pre></td></tr></table></figure><p>这就完了吗？当然不是！观察一下<code>mfhi mflo</code>,他们读取hi和lo的值是要写入<code>rd</code>寄存器的，这就不可避免地带来了数据冲突，因此<code>E_Tnew = (E_Mfhi || E_Mflo) ? 1 : 0;</code></p><p>如此，我们就顺利滑过了E_MDU，庆祝一下吧。</p><h2 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h2><p>我们知道，P6实现了DM外置，所以在CPU内部要实现和外置DM的数据交互。M_BE位于DM之前，处理<strong>store</strong>类指令，这也很好理解，毕竟store是向DM写入数据；相应地，M_DE位于DM之后处理load类指令，因为load是从DM取出数据存入GRF中的。</p><p>先来看M_BE。重要变量</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [ <span class="number">3</span>:<span class="number">0</span>] M_Data_Byteen,  <span class="comment">//字节使能</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] M_Data_Wdata    <span class="comment">//M级DM待写入的数据</span></span><br></pre></td></tr></table></figure><p>四位<code>M_Data_Byteen</code>中的某一位为1代表对应的8位要写入数据，这里只要看仔细<code>sw,sh,sb</code>的Rtl语言正常翻译就行。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (BEOp)</span><br><span class="line">  `BE_SW: <span class="keyword">begin</span></span><br><span class="line">    M_Data_Byteen = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    M_Data_Wdata  = WD;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  `BE_SH: <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (Addr[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">      M_Data_Byteen = <span class="number">4&#x27;b0011</span>;</span><br><span class="line">      M_Data_Wdata  = &#123;<span class="number">16&#x27;b0</span>, WD[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      M_Data_Byteen = <span class="number">4&#x27;b1100</span>;</span><br><span class="line">      M_Data_Wdata  = &#123;WD[<span class="number">15</span>:<span class="number">0</span>], <span class="number">16&#x27;b0</span>&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  `BE_SB: <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b00</span>) <span class="keyword">begin</span></span><br><span class="line">      M_Data_Byteen = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">      M_Data_Wdata  = &#123;<span class="number">24&#x27;b0</span>, WD[<span class="number">7</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b01</span>) <span class="keyword">begin</span></span><br><span class="line">      M_Data_Byteen = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">      M_Data_Wdata  = &#123;<span class="number">16&#x27;b0</span>, WD[<span class="number">7</span>:<span class="number">0</span>], <span class="number">8&#x27;b0</span>&#125;;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">1</span>:<span class="number">0</span>] == <span class="number">2&#x27;b10</span>) <span class="keyword">begin</span></span><br><span class="line">      M_Data_Byteen = <span class="number">4&#x27;b0100</span>;</span><br><span class="line">      M_Data_Wdata  = &#123;<span class="number">8&#x27;b0</span>, WD[<span class="number">7</span>:<span class="number">0</span>], <span class="number">16&#x27;b0</span>&#125;;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      M_Data_Byteen = <span class="number">4&#x27;b1000</span>;</span><br><span class="line">      M_Data_Wdata  = &#123;WD[<span class="number">7</span>:<span class="number">0</span>], <span class="number">24&#x27;b0</span>&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    M_Data_Byteen = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    M_Data_Wdata  = <span class="number">32&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure><h2 id="M-DE"><a href="#M-DE" class="headerlink" title="M_DE"></a>M_DE</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (DEOp)</span><br><span class="line">        `DE_LW : <span class="keyword">begin</span> </span><br><span class="line">            RD = M_Data_Rdata;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        `DE_LH : <span class="keyword">begin</span></span><br><span class="line">            RD = &#123;&#123;<span class="number">16</span>&#123;M_Data_Rdata[<span class="number">16</span> * Addr[<span class="number">1</span>] + <span class="number">15</span>]&#125;&#125;,M_Data_Rdata[(<span class="number">16</span> * Addr[<span class="number">1</span>] + <span class="number">15</span>) -: <span class="number">16</span>]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        `DE_LB : <span class="keyword">begin</span></span><br><span class="line">            RD = &#123;&#123;<span class="number">24</span>&#123;M_Data_Rdata[<span class="number">8</span> * Addr[<span class="number">1</span>:<span class="number">0</span>] + <span class="number">7</span>]&#125;&#125;,M_Data_Rdata[(<span class="number">8</span> * Addr[<span class="number">1</span>:<span class="number">0</span>] + <span class="number">7</span>) -: <span class="number">8</span>]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            RD = <span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure><p><strong>Attention</strong>:<code>[(16 * Addr[1] + 15) -: 16]</code>这里是减，不要写成加法形式。千万别写成加法形式！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>剩下的就是在CTRL里面进行小修小补，在Stall里面完善一下T_new,T_use，在mips里面添加新增的对外交互接口并找到他们对应的连线。此外，所有新添加的指令，除了乘除类，都在P5有过类似的指令，照着之前的添加即可。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</li></ol><p>答：因为乘除法的效率比ALU其他运输运算的效率要低很多（5&#x2F;10），不单独设计的话会让CPU整体效率降低，使用单独的HI，LO寄存器是因为乘除法需要两个寄存器来保存结果，和其他指令需要一个不一样。</p><ol start="2"><li>真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</li></ol><p>答：在真实的流水线 CPU 中，乘法通常有若干个较小的乘法单元组成（组合逻辑），然后每个周期计算特定的几位，依次累加起来，于是会在几个周期后得到正确的最终结果；除法通常使用试商法，通常也是使用组合逻辑在一个周期内计算 4 位左右的商，经过 8 个周期正好可以计算结束。</p><ol start="3"><li>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</li></ol><p>答：当Busy或Start信号为1并且D级为乘除法指令的时候阻塞。</p><ol start="4"><li>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</li></ol><p>答：可以在sh和sb的时候只传入写使能信号和数据，不需要为他们单独设计电路，实现高内聚低耦合。</p><ol start="5"><li>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</li></ol><p>答：不是，是4字节。处理单字节 &#x2F; 非连续字节数据时。</p><ol start="6"><li>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</li></ol><p>答：应当按照cal_r,cal_i,load,store,mult&#x2F;div,branch,jump来分类指令，这样可以将同类型的指令在生成控制信号的时候统一处理。但是我没这么干，感觉这种分类标准不统一，在实现的时候反而要思前想后，相比于单个指令的实现，我还是觉得两者的复杂度相差不大。</p><ol start="7"><li>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</li></ol><p>答：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">mult $<span class="number">1</span>, $<span class="number">2</span></span><br><span class="line">mfhi $<span class="number">3</span></span><br><span class="line">mflo $<span class="number">4</span></span><br></pre></td></tr></table></figure><p>将mfhi和mflo阻塞在D级</p><ol start="8"><li>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</li></ol><p>答：在手动构造数据的时候，在P5的基础上，加入连续操作乘除法的指令，并且在乘除法之间的5-10周期内加入其他指令，来检测新增的指令是否有错误。</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">爱是愚人的国度</span><br><span class="line">不能自拔不懂退出</span><br><span class="line">我们都回不去最初</span><br><span class="line">曾美丽但还是不满足</span><br><span class="line">爱是自愚愚人演出</span><br><span class="line">答案清楚才能谢幕</span><br><span class="line">剧情 是笑 是哭</span><br><span class="line">爱是愚人的国度</span><br><span class="line">看我们演的好辛苦</span><br><span class="line">是你所谓的领悟</span><br><span class="line">我不懂我不哭</span><br><span class="line">看悲欢喜怒每一步</span><br><span class="line">是疲惫还是依赖的束缚</span><br><span class="line">来 你能不能再重复</span><br><span class="line">让我懂让我哭</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P5课下</title>
      <link href="/2026/01/21/P5%E8%AF%BE%E4%B8%8B/"/>
      <url>/2026/01/21/P5%E8%AF%BE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>从P5开始，我们迎来了崭新的篇章，<code>5级流水线</code>。我真的想不出什么其他词汇来形容他的伟大，总之他让无数学生为之倾倒，也让<code>少数</code>情侣为之分道扬镳(别怕)。从这一章节开始，我们设计的CPU难度有了质的飞跃。</p><p>相信很多同学在听了计组理论课关于<code>阻塞</code>和<code>转发</code>的讲解后一头雾水，看了学长的代码之后仍然有一万个为什么。这篇文章笔者将以五级流水线的具体设计为主线，尽可能地解答大家在设计过程中遇到的疑惑，希望能给大家带来一些帮助，如有不详尽之处还请大家多多包涵，也欢迎大家批评指正。</p><h2 id="关于命名方式的一些Tips"><a href="#关于命名方式的一些Tips" class="headerlink" title="关于命名方式的一些Tips"></a>关于命名方式的一些Tips</h2><p>在五级流水线的设计中我们会遇到数不尽的端口，如果命名方式不合理，可能我们在 <code>VScode</code> 的提示下也会云里雾里，但是如果我们有一套自己的命名规则，那么我们可以清楚地识别哪些是端口名称，哪些是连线(实例化时的<code>wire</code>型变量)的名称，从而极大地缩减编码时的工作量和<code>bug</code>率。</p><p>笔者习惯将端口名称大写，将连线名称小写，(<code>clk</code>和<code>reset</code>除外)虽然这种方式不能借助ISE的实例化工具完成，但是至少于编程者而言各变量的含义了然于心，不会越编越乱，以至于自己都不知道自己在干什么。怎么说呢，每个人有每个人独特的方式，大家只要探索到适合自己的命名方式就好。</p><h2 id="设计综述"><a href="#设计综述" class="headerlink" title="设计综述"></a>设计综述</h2><p>五级流水线，顾名思义，当然要弄清楚是哪五级，以及分别有哪些流水线寄存器，以及每一级都包含哪些元件。</p><blockquote><p>F级: IFU<br>D级：CMP,EXT,GRF,NPC,D_reg<br>E级：E_ALU,E_reg<br>M级：M_DM,M_reg<br>W级：W_reg</p></blockquote><p>显然，五级流水线，四个流水线寄存器，构成了P5设计的基本框架。除此之外，还有<code>Stall</code>模块用来处理阻塞，<code>mips</code>模块在组装元件的过程中实现转发，<code>def</code>模块定义一些宏，<code>CTRL</code>模块实现控制信号以及配合<code>Stall</code>模块实现阻塞判断。</p><p>设计图可以参照：<br><img src="/images/Five-Stage_Pipeline_Logisim_Schematic.png" alt="Five-Stage Pipeline Logisim Schematic"></p><p>P5课下要求实现的指令是：add, sub, ori, lw, sw, beq, lui, jal, jr, nop。由于接口繁多，笔者在搭建时本着接口<code>能少就少</code>的原则完成设计，(当然也要给课上留好一定的扩展接口)。</p><p>在大家大概了解了每一个模块的作用以及我们要实现的具体指令以后我们就可以进入详细的设计分析了。</p><h2 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> F_IFU (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] NPC,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> PCWE,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] PC,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] Instr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>F_IFU</code>和<code>P4</code>相比变化不大只是在输入中新增了<code>PCWE</code>。当<code>Stall</code>生效时，<code>IFU</code>中的<code>PC</code>不再更新，直到阻塞结束。</p><h2 id="D-reg"><a href="#D-reg" class="headerlink" title="D_reg"></a>D_reg</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> D_reg (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> Flush,   </span><br><span class="line">    <span class="keyword">input</span> WE,    </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] F_PC,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] F_Instr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] D_PC,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] D_Instr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>D级寄存器负责连接F级和D级流水线，因为课程组规定阻塞只能发生在<strong>D级</strong>，因此当阻塞指令生效时，<code>WE</code>禁止向<code>D级</code>寄存器写入指令，<code>Flush</code>刷新E级寄存器为<code>nop</code>，从而使得<code>nop</code>信号随着流水线流下去，从而实现阻塞。</p><blockquote><p>Q: PC和Instr要一直流水下去吗？<br>A: 是的。只有PC和instr随流水线一直流水下去我们才能判断每一级流水线的当前指令是什么。</p></blockquote><p><strong>instr主要用途</strong>：阻塞判断，每一级流水线译码(分布式)。<br><strong>PC主要用途</strong>：<code>DM</code>要输出<code>PC</code>，<code>jal</code>指令向<code>GPR[rs]</code>写入涉及<code>PC</code>，</p><h2 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> D_EXT (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] imm,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] ext,</span><br><span class="line">    <span class="keyword">input</span> EXTOp</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>EXT</code>和<code>P4</code>没有什么区别。</p><h2 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> D_CMP (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] RS,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] RT,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] CMPOp,    <span class="comment">//提前为其他转移信号留下接口</span></span><br><span class="line">    <span class="keyword">output</span> Beq_jump</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>D_CMP</code>存在的意义是将<code>BEQ</code>的比较提前，这样可以尽早判断是否跳转，减少流水线的”白流”。</p><h2 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> D_NPC (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] F_PC,   <span class="comment">//正常计算F_PC+4</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_PC,   <span class="comment">//流水</span></span><br><span class="line">    <span class="keyword">input</span> Beq_jump,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] NPCOp,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] RA,     <span class="comment">//jr和jalr用</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">25</span>:<span class="number">0</span>] IMM,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] NPC</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>在<code>D_NPC</code>模块的接口相较于<code>P4</code>多出了<code>Beq_jump</code>,<code>F_PC</code>,<code>D_PC</code>三个信号。<code>Beq_jump</code>不必赘述，我们重点区分一下<code>F_PC</code>和<code>D_PC</code>以及他们的用法。<br>首先大家需要明确,在一般情况下:<code>F_PC = D_PC + 4</code>。(因为流水线走了一级嘛)。</p><p>接着我们来看一个流水线简图：</p><table><thead><tr><th>时钟周期</th><th>F级（取指）</th><th>D级（译码）</th><th>E级（执行）</th><th>M级（访存）</th><th>W级（写回）</th></tr></thead><tbody><tr><td>拍1</td><td>取 BEQ（0x00）</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>拍2</td><td>取下条 A（0x04）</td><td>译 BEQ（0x00）并判断</td><td>-</td><td>-</td><td>-</td></tr><tr><td>拍3</td><td>取下下条 B（0x?）</td><td>译下条 A（0x04）</td><td>执行BEQ对地址的更改</td><td>-</td><td>-</td></tr></tbody></table><p>我们可以采用类似延迟槽的思想，<code>A</code>指令无论如何都会被执行，那么我们重点考虑<code>B</code>指令。</p><p><strong>如果</strong> <code>Beq_jump = 0</code>，我们应该接着F_PC取PC + 4，这也就决定了<code>assign PC_4 = F_PC + 4</code>;</p><p><strong>如果</strong> <code>Beq_jump = 1</code>，那我们根据Beq的RTL语言。PC+4使用的应该是D_PC，这也决定了<code>assign IMM_BEQ = &#123;&#123;14&#123;IMM[15]&#125;,IMM[15:0],2'b0&#125;&#125; + D_PC + 4</code>。</p><p>根据上述分析，我们可以同理得出，<code>assign IMM_J_Jal = &#123;D_PC[31:28],IMM,2&#39;b0&#125;</code></p><h2 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> D_GRF (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] PC,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] A1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] A2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] A3,       </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] WD,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] RD1,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] RD2</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在<code>GRF</code>这个模块，虽然模块名称叫<code>D_GRF</code>(因为这里理论上只读，在W级才执行写操作)，但是由于全局<code>GRF</code>的唯一性，我们保留了<code>WD</code>,<code>A3</code>这两个写入数据必要的接口，当指令流水到<code>W级</code>时，根据<code>A3是否等于0</code>来决定是否写入。</p><p>为什么是根据<code>A3是否等于0</code>来决定是否写入呢，因为我们在这里为了简化设计采用了<code>隐式写使能</code>，即取消<code>显式WE信号</code>，转而通过<code>A3</code>的取值来决定是否写入<code>GRF</code>。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (A3 != <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">    register[A3] &lt;= WD;</span><br><span class="line">    display(<span class="string">&quot;%d@%h: $%d &lt;= %h&quot;</span>,<span class="built_in">$time</span>,PC,A3,WD);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于<code>A3</code>的取值，<code>CTRL</code>模块会出手的，我们在<code>CTRL</code>会详细解释，这里大家只要留个印象即可。因为是在<code>W</code>级流水线写入，所以聪明的你应该可以感觉到<code>WD</code>，<code>A3</code>在<code>mips</code>模块实例化时对应的<code>wire</code>是什么了吧，没猜到也没关系，我们接着往下看。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> RD1 = (A1 == <span class="number">0</span>) ? <span class="number">32&#x27;b0</span> : (A1 == A3) ? WD : register[A1];</span><br><span class="line"><span class="keyword">assign</span> RD2 = (A2 == <span class="number">0</span>) ? <span class="number">32&#x27;b0</span> : (A2 == A3) ? WD : register[A2];</span><br></pre></td></tr></table></figure><p>这段代码翻译过来就是，如果访问<code>0</code>号寄存器，直接给出<code>0</code>，如果访问的寄存器和<code>A3</code>冲突，那就给出<code>WD</code>的值，如果都不是，那就正常给出<code>register[A1]</code>。</p><p>当进入<code>A1</code>和<code>A3</code>冲突的分支时，那么<code>A3</code>一定不为<code>0</code>，相当于写使能有效。这段代码的作用就更加明显：**如果访问的寄存器和W级流水线将要写入的寄存器冲突，那么给出的值是将要写入的WD而不是现在的寄存器值register[A1]**。</p><p>这就是<strong>转发</strong>！！！只不过这是<code>GRF</code>内部转发，我们在<code>mips</code>模块中大量实现的是外部转发。大家还是留个印象，到时候再说😁。</p><h2 id="E-reg"><a href="#E-reg" class="headerlink" title="E_reg"></a>E_reg</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> E_reg (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> Flush,</span><br><span class="line">    <span class="keyword">input</span> WE,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_PC,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_Instr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_EXT,   <span class="comment">//要用于ALU的计算</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_Rs_data, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_Rt_data,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] E_PC,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] E_Instr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] E_EXT,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] E_Rs_data,   </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] E_Rt_data</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>E_reg</code>的接口相较于<code>D_reg</code>又多了<code>D_EXT</code>,<code>D_Rs_data</code>,<code>D_Rt_data</code>,这三个量都是<code>E</code>级不可或缺的变量，所以也没什么可说的😥。</p><h2 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> E_ALU (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] B,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] ALUOp,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] C  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个也再正常不过了，我们下一个。</p><h2 id="M-reg"><a href="#M-reg" class="headerlink" title="M_reg"></a>M_reg</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> M_reg (</span><br><span class="line">    <span class="keyword">input</span> Flush,</span><br><span class="line">    <span class="keyword">input</span> WE,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] E_PC,      </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] E_Instr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] E_Rt_data,  <span class="comment">//sw用</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] E_C,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] M_PC,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] M_Instr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] M_Rt_data,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] M_C</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>M_reg</code>相较于<code>E_reg</code>多了<code>E_C</code>,这是<code>ALU</code>计算出的结果，肯定要往后流水，<code>M</code>级和<code>W</code>级都要用。少了的就是没用了，端口太多，全传过去有点抽象😥。</p><h2 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> M_DM (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> DMWE,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] PC,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] Addr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] WD,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] RD</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="W-reg"><a href="#W-reg" class="headerlink" title="W_reg"></a>W_reg</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> W_reg (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> Flush,</span><br><span class="line">    <span class="keyword">input</span> WE,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] M_PC,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] M_Instr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] M_RD,       <span class="comment">//往GRF写入与DM的运算结果有关</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] M_C,        <span class="comment">//往GRF写入与ALU的运算结果有关</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] W_PC,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] W_Instr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] W_RD,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] W_C</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>至此，我们完成了各个元件的搭建，其实<code>P5</code>和<code>P4</code>相比，这些基本元件几乎没变，变的是<code>CTRL</code>，<code>mips</code>,还新增了<code>Stall</code>。</p><p>接下来就是<code>P5</code>的核心，也是最难的部分————<strong>阻塞与转发</strong>。</p><hr><h2 id="CTRL"><a href="#CTRL" class="headerlink" title="CTRL"></a>CTRL</h2><p>CTRL是译码器，主流的有两种设计方式：</p><p><strong>集中式译码</strong> ：在取指令（F 级）时或者读取寄存器阵列信息（D 级）前，将所有的控制信号全部解析出，然后让其随着流水往后逐级传递。</p><p><strong>分布式译码</strong> ：每一级都部署一个译码器，负责译出当前级所需控制信号。</p><p>为了尽可能减少一个模块中的接口数量，这里采用分布式译码。在设计CTRL模块时输出包含所有的<strong>控制信号</strong>以及<strong>rs,rt</strong>…在每一级可能会用到的信号，在<code>mips</code>模块中只需要在每一级流水线译出该级流水线所需的信号即可。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> CTRL (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] Instr,</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] Rs,     <span class="comment">//转发冲突判断</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] Rt,     <span class="comment">//转发冲突判断</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] Rd,     <span class="comment">//转发冲突判断的待选择信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] Imm1,  <span class="comment">//EXT用</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">25</span>:<span class="number">0</span>] Imm2,  <span class="comment">//NPC用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> EXTOp,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] CMPOp,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] NPCOp,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] ALUOp,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] ALUBSel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] GRFWDSel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] GRFA3Sel,</span><br><span class="line">    <span class="keyword">output</span> DMWE,</span><br><span class="line">    <span class="comment">//配合Stall</span></span><br><span class="line">    <span class="keyword">output</span> Add,</span><br><span class="line">    <span class="keyword">output</span> Sub,</span><br><span class="line">    <span class="keyword">output</span> Ori,</span><br><span class="line">    <span class="keyword">output</span> Lw,</span><br><span class="line">    <span class="keyword">output</span> Sw,</span><br><span class="line">    <span class="keyword">output</span> Beq,</span><br><span class="line">    <span class="keyword">output</span> Lui,</span><br><span class="line">    <span class="keyword">output</span> Sll,</span><br><span class="line">    <span class="keyword">output</span> J,</span><br><span class="line">    <span class="keyword">output</span> Jal,</span><br><span class="line">    <span class="keyword">output</span> Jr,</span><br><span class="line">    <span class="keyword">output</span> Jalr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>控制信号具体值可以参看译码表。如图：</p><table><thead><tr><th align="center">指令</th><th align="center">opcode(31:26)</th><th align="center">funct(5:0)</th><th align="center">EXTOp</th><th align="center">CMPOp</th><th align="center">NPCOp</th><th align="center">ALUOp</th><th align="center">ALUBSel</th><th align="center">GRFWDSel</th><th align="center">GRFA3Sel</th><th align="center">DMWE</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">opcode</td><td align="center">func</td><td align="center">立即数扩展</td><td align="center">比较器操作</td><td align="center">下一条PC计算</td><td align="center">ALU运算</td><td align="center">ALUB端口选择</td><td align="center">GRF写回数据来源</td><td align="center">GRF写回地址选择</td><td align="center">数据存储器写使能</td></tr><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_add</td><td align="center">ALUBrt</td><td align="center">GRFWDALU</td><td align="center">GRFA3rd</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_sub</td><td align="center">ALUBrt</td><td align="center">GRFWDALU</td><td align="center">GRFA3rd</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center">x</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_ori</td><td align="center">ALUBimm</td><td align="center">GRFWDALU</td><td align="center">GRFA3rt</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center">x</td><td align="center">EXT_SIGN</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_add</td><td align="center">ALUBimm</td><td align="center">GRFWDDM</td><td align="center">GRFA3rt</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center">x</td><td align="center">EXT_SIGN</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_add</td><td align="center">ALUBimm</td><td align="center">GRFWDALU</td><td align="center">GRFA3rt</td><td align="center">DMWE_ONE</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center">x</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_BEQ</td><td align="center">ALU_sub</td><td align="center">ALUBrt</td><td align="center">GRFWDALU</td><td align="center">GRFA3rt</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center">x</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_lui</td><td align="center">ALUBimm</td><td align="center">GRFWDALU</td><td align="center">GRFA3rt</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">sll</td><td align="center">000000</td><td align="center">000000</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_PC4</td><td align="center">ALU_sll</td><td align="center">ALUBrt</td><td align="center">GRFWDALU</td><td align="center">GRFA3rd</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">j</td><td align="center">000010</td><td align="center">x</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_J_Jal</td><td align="center">ALU_add</td><td align="center">ALUBrt</td><td align="center">GRFWDALU</td><td align="center">GRFA3rt</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">jal</td><td align="center">000011</td><td align="center">x</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_J_Jal</td><td align="center">ALU_add</td><td align="center">ALUBrt</td><td align="center">GRFWDPC8</td><td align="center">GRFA331</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">jr</td><td align="center">000000</td><td align="center">001000</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_Jr_Jalr</td><td align="center">ALU_add</td><td align="center">ALUBrt</td><td align="center">GRFWDALU</td><td align="center">GRFA3rd</td><td align="center">DMWE_ZERO</td></tr><tr><td align="center">jalr</td><td align="center">000000</td><td align="center">001001</td><td align="center">EXT_ZERO</td><td align="center">CMP_BEQ</td><td align="center">NPC_Jr_Jalr</td><td align="center">ALU_add</td><td align="center">ALUBrt</td><td align="center">GRFWDPC8</td><td align="center">GRFA3rd</td><td align="center">DMWE_ZERO</td></tr></tbody></table><h2 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h2><p>阻塞的概念是,当我们发现单凭转发已经不足以解决读写冲突的问题时，不得不让当前指令停在<strong>D级</strong>，直到随流水线流水的指令产生写入数据的时间<code>(Tnew)</code>小于等于D级指令将要读取寄存器的时间<code>(Tuse)</code>,D级流水线寄存器才<strong>放行</strong>，在这期间一直是<code>nop</code>从<code>E</code>级不断向后流水。</p><p>这里我们对<strong>Tnew</strong>和<strong>Tuse</strong>做详细阐释：</p><p><strong>Tuse</strong>:对于某一个指令的某一个数据需求，我们定义需求时间<strong>Tuse</strong>为：</p><p>这条指令位于 <strong>D</strong> 级的时候，再经过多少个时钟周期就必须要使用相应的数据。例如，对于 <code>beq</code> 指令，立刻就要使用数据，所以 <code>Tuse = 0</code>;对于 <code>add</code> 指令，等待下一个时钟周期它进入 E 级才要使用数据，所以 <code>T_use = 1</code>;而对于 <code>sw</code> 指令，在 E 级它需要 GPR[rs] 的数据来计算地址，在 M 级需要 GPR[rt] 来存入值，所以 <code>rs_Tuse = 1,rt_Tuse = 2</code>。</p><p><strong>Tnew</strong>: 对于某个指令的数据产出，我们定义供给时间<strong>Tnew</strong>为：</p><p>位于<strong>某个流水级</strong>的某个指令，它经过多少个时钟周期可以算出结果并且存储到<strong>流水级寄存器</strong>里。注意是<strong>流水级寄存器</strong>，不是<strong>GRF</strong>。对于 <code>add</code> 指令，当它处于 E 级，此时结果还没有存储到流水级寄存器里，所以此时它的 <code>Tnew = 1</code>,而当它处于 M 或者 W 级，此时结果已经写入了流水级寄存器，所以此时 <code>Tnew = 0</code>.</p><blockquote><p>当Tnew &gt; Tuse 时，数据不能及时算出，需要通过阻塞来解决。<br>当Tnew &lt;&#x3D; Tuse 数据能够及时算出，可以转发解决。</p></blockquote><p>由于<code>Tnew</code>的是一个<strong>动态值</strong>，而<code>Tuse</code>为一个<strong>静态值</strong>，随着<code>Tnew</code>的不断减小，当<code>Tnew = Tuse</code> 时，D级流水线寄存器就可以<strong>放行</strong>了。以上就是阻塞的大概过程，我们看具体的代码再做理解。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> STALL (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_instr,   </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] E_instr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] M_instr,</span><br><span class="line">    <span class="keyword">output</span> Stall</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在D级只产生<code>Tuse</code>,在<code>E</code>，<code>M</code>级产生<code>Tnew</code>,(W级Tnew恒等于0)我们只需要分三个区间分别写出对应的<code>Tnew</code>,<code>Tuse</code>,然后列出阻塞情况，最后通过<strong>或运算</strong>就可以得到阻塞信号<code>Stall</code>;</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> E_stall_rs = (D_rs == E_GRFA3 &amp;&amp; (D_rs != <span class="number">0</span>)) &amp;&amp; (rs_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> E_stall_rt = (D_rt == E_GRFA3 &amp;&amp; (D_rt != <span class="number">0</span>)) &amp;&amp; (rt_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rs = (D_rs == M_GRFA3 &amp;&amp; (D_rs != <span class="number">0</span>)) &amp;&amp; (rs_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rt = (D_rt == M_GRFA3 &amp;&amp; (D_rt != <span class="number">0</span>)) &amp;&amp; (rt_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> Stall = E_stall_rs | E_stall_rt | M_stall_rs | M_stall_rt;</span><br></pre></td></tr></table></figure><p>第一行代表的含义是<strong>E级导致阻塞，rs地址冲突</strong>。注意，当<code>rs = 0</code>是，默认寄存器的值已知，不需要阻塞。这里附上<code>Tnew</code>和<code>Tuse</code>的阻塞表。</p><p><strong>D_Tuse</strong>:</p><table><thead><tr><th align="center">指令</th><th align="center">add</th><th align="center">sub</th><th align="center">ori</th><th align="center">lw</th><th align="center">sw</th><th align="center">beq</th><th align="center">lui</th><th align="center">sll</th><th align="center">j</th><th align="center">jr</th><th align="center">jal</th><th align="center">jalr</th></tr></thead><tbody><tr><td align="center">D_rs_Tuse</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">D_rt_Tuse</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td></tr></tbody></table><p><strong>E_Tnew &amp; M_Tnew</strong>:</p><table><thead><tr><th align="center">指令</th><th align="center">add</th><th align="center">sub</th><th align="center">ori</th><th align="center">lw</th><th align="center">sw</th><th align="center">beq</th><th align="center">lui</th><th align="center">sll</th><th align="center">j</th><th align="center">jr</th><th align="center">jal</th><th align="center">jalr</th></tr></thead><tbody><tr><td align="center">E_Tnew</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">M_Tnew</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h2 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h2><p>阻塞处理完，我们就要开始实例化模块并连接电路了，连接过程中实现<strong>外部转发</strong>，我们的五级流水线CPU就基本搭建完成了。总体来说，我们的设计主线是模块的实例化，在实例化过程中我们会发现某个需要使用的变量的缺失，这时我们在每一级的固定定义区定义我们需要的<code>wire</code>类型变量即可，大家完全不必纠结于在每一个模块开始时定义什么。</p><p><strong>特别的，E_GRFa3,E_GRFwd系列的指令需要在开头定义，因为这些指令如果在对应模块定义的话就会出现在定义前使用的情况，使用时编译器会自动隐式定义为1位的wire变量，如果你在之后再次定义的话，编译器会报错重复定义</strong>。</p><p>笔者这里在全局定义区定义了常用变量，大家可以参考这种定义方式，也可以放在固定的流水级，<strong>你开心就好</strong>😊</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//各级PC和Instr</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] F_pc,F_instr,D_pc,D_instr,E_pc,E_instr,M_pc,M_instr,W_pc,W_instr;</span><br><span class="line"><span class="comment">//阻塞信号</span></span><br><span class="line"><span class="keyword">wire</span> stall;</span><br><span class="line"><span class="comment">//各级流水线寄存器使能信号和刷新信号</span></span><br><span class="line"><span class="keyword">wire</span> D_reg_flush,E_reg_flush,M_reg_flush,W_reg_flush,D_reg_we,E_reg_we,M_reg_we,W_reg_we;</span><br><span class="line"><span class="comment">//PC的使能信号</span></span><br><span class="line"><span class="keyword">wire</span> PCwe;</span><br></pre></td></tr></table></figure><p>接下来强调几个重要的模块。</p><h3 id="stall"><a href="#stall" class="headerlink" title="stall"></a>stall</h3><p>阻塞模块是全局变量，需要作为单独一个实例来控制各个流水线寄存器的运作，Stall的取值可能会影响的变量是<code>PC_we</code>,<code>D_reg_we</code>,<code>E_reg_flush</code>。</p><h3 id="D级"><a href="#D级" class="headerlink" title="D级"></a>D级</h3><p><code>D</code>级<code>GRF</code>实例化时<code>A3</code>接口和<code>WD</code>接口分别接<code>W_GRFa3</code>和<code>W_GRFwd</code>，从而实现GRF<strong>内部转发</strong>。而由于W级实现了内部转发，我们在转发<code>D_For_rs_data</code>和<code>D_For_rt_data</code>时只转发<code>E</code>，<code>M</code>即可：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> D_For_rs_data = (D_rs == <span class="number">5&#x27;d0</span>) ? <span class="number">32&#x27;d0</span> :</span><br><span class="line">                       (D_rs == E_GRFa3) ? E_GRFwd :</span><br><span class="line">                       (D_rs == M_GRFa3) ? M_GRFwd :</span><br><span class="line">                       D_rs_data;</span><br></pre></td></tr></table></figure><p>这里很多同学会问，转发时如何保证<code>E_GRFwd</code>，<code>M_GRFwd</code>已经算出来了呢，其实很简单，当你在执行转发时，是不是说明<strong>不需要阻塞了</strong>，那不需要阻塞是否意味着你要的东西已经算出来了呢？</p><p>注意<code>D_NPC</code>和<code>D_CMP</code>用的<code>D_rs_data</code>和<code>D_rt_data</code>都是<strong>转发后的</strong>。</p><h3 id="E级"><a href="#E级" class="headerlink" title="E级"></a>E级</h3><p>因为<code>E</code>级没有<code>GRF</code>，即没有内部转发，因此<code>E</code>级<code>E_For_rs_data</code>和<code>E_For_rt_data</code>需要转发<code>M</code>，<code>W</code>。并且在<code>E</code>级要实现<code>E_GRFa3</code>和<code>E_GRFwd</code>这两个转发必要的数据赋值，<code>E_GRFa3</code>实现没什么坑点，值得一提的是，<code>E_GRFwd</code>没有<code>DMrd</code>这个选项，因为在<code>E</code>级，还没有算出<code>M</code>级的结果。</p><p>注意<code>E_ALU</code>用的<code>E_rs_data</code>和<code>E_rt_data</code>是<strong>转发后的</strong>。</p><h3 id="M级"><a href="#M级" class="headerlink" title="M级"></a>M级</h3><p><code>M</code>级只需要转发<code>rt_data</code>,因为<code>rs_data</code>不会在<code>M</code>级被使用。同理实现<code>M_GRFa3</code>和<code>M_GRFwd</code>，此时<code>M_GRFwd</code>有了<code>DMrd</code>这个选项。</p><p>注意<code>M_DM</code>用的<code>M_rt_data</code>是<strong>转发后</strong>的结果。</p><h3 id="W级"><a href="#W级" class="headerlink" title="W级"></a>W级</h3><p><code>W</code>级没什么好转发的，只需要实现<code>W_GRFa3</code>和<code>W_GRFwd</code>即可。</p><h2 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h2><ol><li>P5确实难，大家如果一开始上不了手也完全没关系，这不是你的问题。</li><li>老师会建议大家先写设计文档，再搭建CPU。听着很有道理哈，但是对于大部分同学来说听完理论课根本不知道从哪里下手，只能死磕设计文档。你可以把死磕设计文档理解成<strong>盯着markdown学P5</strong>，你就知道这种<strong>推荐行为</strong>有多搞笑了……(当然大佬除外，确实有些同学是具备直接上手设计文档的能力的)。我的建议是大家完全可以直接照着学长的博客搭一遍，搭的过程中你一定会有很多疑问，只要做标记就好，在你搭建的过程中你会对某些问题有自己的理解，在搭建完成后再把整个CPU过一遍，找出自己不理解的地方专项攻克。在做完这些工作之后你一定会对流水线CPU有更深刻的理解，这时你再把<code>Stall</code>，<code>mips</code>，<code>CTRL</code>这三个重点模块自己重新写一遍，就形成了属于自己的CPU。个人感觉这种<strong>盯着代码学P5</strong>要比<strong>盯着markdown学P5</strong>好很多。</li><li>这篇Blog只是介绍了课下的基础指令，单凭这些工作就想<strong>P5课上过，片叶不沾身</strong>有点困难，我们还需要完善某些接口，详见关于P5课上的<a href="https://cordial-kid.github.io/2026/01/21/P5%E8%AF%BE%E4%B8%8A/">这篇博客</a>。</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>P5作为流水线CPU的开山之P，是后面几次实验的基础，同学们要认真对待。这篇博客说了这么多，虽然不能让你在看完之后立刻原地完美搭建5级流水线CPU，但是只要其中的一些细节解释能给你些许灵感,足矣。</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">修炼爱情的悲欢</span><br><span class="line">我们这些努力不简单</span><br><span class="line">快乐炼成泪水</span><br><span class="line">是一种勇敢</span><br><span class="line">几年前的幻想</span><br><span class="line">几年后的原谅</span><br><span class="line">为一张脸去养一身伤</span><br><span class="line">别讲想念我</span><br><span class="line">我会受不了这样</span><br><span class="line">笑着说爱让人疯狂</span><br><span class="line">哭着说爱让人紧张</span><br><span class="line">忘不了那个人就投降</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」P5课上</title>
      <link href="/2026/01/21/P5%E8%AF%BE%E4%B8%8A/"/>
      <url>/2026/01/21/P5%E8%AF%BE%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>P5课上三题有明显得规律，第一题一般只涉及ALU的修改，第二题是b类型的跳转指令，第三题稍微难一点，涉及访存以及对转发阻塞逻辑的修改。下面我们结合题目详细说明一下解题思路和步骤。</p><h2 id="CCC"><a href="#CCC" class="headerlink" title="CCC"></a>CCC</h2><p>opcode &#x3D; 忘了</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tmp1 = GPR[rs]的前导零</span><br><span class="line">tmp2 = GPR[rt]的前导一</span><br><span class="line">if (tmp1 &gt; tmp2) GPR[rd] &lt;- GPR[rs][31:16] || GPR[rt][15:0]</span><br><span class="line">else GRP[rd] &lt;- GPR[rt][31:16] || GPR[rs][15:0]</span><br></pre></td></tr></table></figure><p><strong>Answer</strong>:在<code>ALU</code>把<code>tmp1</code>和<code>tmp2</code>的值计算出来，并通过<code>ALUOp</code>控制<code>ALU</code>输出不同的结果。在<code>CTRL</code>模块新增指令，使得该指令写入<code>GPR[rd]</code>,并且写入数据为<code>ALU</code>输出结果。在<code>Stall</code>模块中<code>Tnew</code>和<code>Tuse</code>无脑跟<code>add</code>保持一致即可。</p><h2 id="BLONEZ-应该吧"><a href="#BLONEZ-应该吧" class="headerlink" title="BLONEZ?(应该吧)"></a>BLONEZ?(应该吧)</h2><p>opcode &#x3D; 111111</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tmp = GPR[rs]前导1</span><br><span class="line">GPR[31] &lt;- PC + 8;</span><br><span class="line">if (tmp1 &gt; GPT[rt][5:0]) </span><br><span class="line">PC &lt;- IMMbeq的跳转方式</span><br></pre></td></tr></table></figure><p>这个是考场题目，但是比较简单，大家感兴趣可以看一看，我们用一道推荐题来说明这类型题目的解决方法。</p><h2 id="BLZTAL"><a href="#BLZTAL" class="headerlink" title="BLZTAL"></a>BLZTAL</h2><p>opcode &#x3D; 100111</p><p>看题：<br><img src="/images/BLZTAL.png" alt="BLZTAL"></p><p><strong>Answer</strong>:对于<code>b</code>型指令，我们要在<code>D_CMP</code>模块中判断<code>b_jump</code>，如果是条件链接(像这道题)，我们就要将<code>D_CMP</code>模块中的<code>b_jump</code>指令随着流水线一直流水下去，从而满足每一级的<code>CTRL</code>判断<code>GRFA3sel</code>和<code>GRFWDsel</code>信号的需求;如果是无条件链接(像<strong>BLONEZ</strong>)，那CTRL直接生成控制信号写入<code>31</code>号寄存器，写入值是<code>PC + 8</code>即可。在<code>STALL</code>模块<code>Tuse</code>和<code>Tnew</code>与<code>Beq</code>保持一致。</p><p>对于链接类指令Tuse,Tnew参照<code>jal</code>就行</p><p>特别注意一下PC的变化基数是D_PC还是F_PC。</p><p>还有一种情况可能会涉及清空延迟槽的指令，像这样：</p><p><img src="/images/BONALL.png" alt="BONALL"></p><p>为什么要清空延迟槽呢，我理解就是不想执行跳转类指令的下一条指令了，把他用Flush清除掉。具体实现需要在D_CMP增加一个接口Flush_check<code>assign Flush_check = (CMPOp == `CMP_BONALL &amp;&amp; !B_jump);</code>,在<code>mips</code>中将这一接口与<strong>D_reg_flush**相连，<code>assign D_reg_flush = (!stall &amp;&amp; D_flush_check);</code>值得注意的是，我们要保证此时流水线不是阻塞状态.如果是阻塞状态我们就等到它阻塞结束再清空，想想为什么呢？因为如果流水线阻塞在D级的话，D级放的其实是跳转类指令，相当于是</strong>把自己送走了**，后面的流水级就丢失了这条指令。</p><h2 id="LBGET"><a href="#LBGET" class="headerlink" title="LBGET"></a>LBGET</h2><p>opcode &#x3D; 110101</p><p><img src="/images/LBGET.png" alt="LBGET"></p><p><strong>Answer</strong>:这是写入地址可选择类<code>condition: GPR[rt] &lt;- RD; else: GPR[rs] &lt;- RD</code>,我们只有在DM完成计算才能知道要写入哪个寄存器，那么<code>D，E，(M)</code>就都<strong>没GRFA3的视野</strong>，因此难以判断冲突条件是否成立。此时我们有两个选择：<strong>暴力阻塞</strong>;<strong>条件阻塞</strong>。</p><p><strong>暴力阻塞</strong>:只要D级指令要访问GPR，并且访问地址非0，并且Tuse &lt; Tnew，我们就阻塞。对应代码实现</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> E_stall_rs = ((E_lbget ? <span class="number">1</span> : (E_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> E_stall_rt = ((E_lbget ? <span class="number">1</span> : (E_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rs = ((M_lbget ? <span class="number">1</span> : (M_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rt = ((M_lbget ? <span class="number">1</span> : (M_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; M_Tnew);</span><br></pre></td></tr></table></figure><p><strong>条件阻塞</strong>：D级指令要访问GPR,并且访问地址非0，并且访问地址和当前级流水线的 <code>rs</code> 或 <code>rt</code> 冲突，并且 <code>Tuse &lt; Tnew</code>,我们阻塞。对应代码实现。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> E_stall_rs = ((E_lbget ? (D_rs == E_rt || D_rs == E_rs) : (E_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> E_stall_rt = ((E_lbget ? (D_rt == E_rs || D_rt == E_rt) : (E_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rs = ((M_lbget ? (D_rs == M_rs || D_rs == M_rt) : (M_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rt = ((M_lbget ? (D_rt == M_rs || D_rt == M_rt) : (M_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; M_Tnew);</span><br></pre></td></tr></table></figure><p>以上是两种阻塞方式，暴力阻塞可能会超时，条件阻塞也可能比测评机要求的周期少(可能是跑的太快了😥)。接着还有两种译码位置，<strong>M级译码</strong>和<strong>W级译码</strong></p><p><strong>W级译码</strong>：对于判断条件Condition，我们不在DM进行计算，而是在顶层模块mips中进行判断，DM只需要更改DMOp从而输出判断需要的数据即可。这里你可能会发现，如果我要写入的数据来自DM并且和我判断需要的数据冲突了怎么办呢，那就只好再给DM开一个端口往后传判断需要的数据了。在W级判断出condition后传到<code>w_ctrl</code>,对<code>W_GRFA3</code>判断。显然，在这种情况下，<code>D</code>，<code>E</code>，<code>M</code>级都没有GRFA3的视野所以<code>E_Tnew = 3</code>,<code>M_Tnew = 2</code>,并且条件阻塞写法如下：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stall</span></span><br><span class="line"><span class="keyword">assign</span> E_stall_rs = ((E_lbget ? (D_rs == E_rt || D_rs == E_rs) : (E_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> E_stall_rt = ((E_lbget ? (D_rt == E_rs || D_rt == E_rt) : (E_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rs = ((M_lbget ? (D_rs == M_rs || D_rs == M_rt) : (M_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rt = ((M_lbget ? (D_rt == M_rs || D_rt == M_rt) : (M_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; M_Tnew);</span><br></pre></td></tr></table></figure><p>这样就可以得到正确的运算结果，但是不难看出，这并不是最优解，我们在M级其实就可以拿到GRFA3，这样就可以删除M级冲突判断的不确定性，从而减少阻塞的发生，提高CPU性能。</p><p>至于为什么会提到这种在W级译码的方式，21级的很多学长似乎采用了这种做法，优点是<strong>当condition判断需要的数据和DM输出的数据相同时，可以对电路做最小的改动实现功能</strong>，缺点也很明显<strong>运行效率较低并且当condition判断需要的数据和DM输出的数据不相同时需要新增接口</strong>。对了，笔者在测评机提交这种方法时出现了一个测试点TLE，所以这种方法大家听个思路，考场慎用吧。</p><p><strong>M级译码</strong>：对于判断条件condition，我们在DM计算出并且随流水线流到W级，这样M级流水线寄存器就可以较早地拿到GRFA3。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> M_GRFa3 = (M_GRFA3_sel == `GRFA3rt) ? M_rt :</span><br><span class="line">                 (M_GRFA3_sel == `GRFA3rd) ? M_rd :</span><br><span class="line">                 (M_GRFA3_sel == `GRFA331 ) ? <span class="number">5&#x27;d31</span> :</span><br><span class="line">                 (M_GRFA3_sel == `GRFA3rs) ? M_rs :</span><br><span class="line">                 (M_GRFA3_sel == `GRFA30 &amp;&amp; M_lbget &amp;&amp; M_condition1 == <span class="number">1</span>) ? M_rt :</span><br><span class="line">                 (M_GRFA3_sel == `GRFA30 &amp;&amp; M_lbget &amp;&amp; M_condition1 == <span class="number">0</span>) ? M_rs :</span><br><span class="line">                 <span class="number">5&#x27;d0</span>;</span><br></pre></td></tr></table></figure><p>在Stall模块中因为要判断M_GRFA3，所以需要将condition信号传入Stall</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> STALL (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] D_Instr,  </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] E_Instr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] M_Instr,</span><br><span class="line">    <span class="keyword">input</span> Condition1,</span><br><span class="line">    <span class="keyword">output</span> Stall</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>M_GRFA3</code>已知，所以<code>E_Tnew = 2</code> ,<code>M_Tnew = 1</code>,并且条件阻塞判断如下:</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stall</span></span><br><span class="line"><span class="keyword">assign</span> E_stall_rs = ((E_lbget ? (D_rs == E_rt || D_rs == E_rs) : (E_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> E_stall_rt = ((E_lbget ? (D_rt == E_rs || D_rt == E_rt) : (E_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rs = ((M_GRFA3 == D_rs) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rt = ((M_GRFA3 == D_rt) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; M_Tnew);</span><br></pre></td></tr></table></figure><p>注意，关于GRFA3的译码，如果按照笔者个人的习惯，会将condition传入CTRL模块完成GRFA3_Sel译码,但是我们发现在M级，</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">m_ctrl(<span class="variable">.Condition</span>(condition),<span class="variable">.DMOp</span>(DMop)) ;</span><br><span class="line">m_dm(<span class="variable">.DMOp</span>(DMop),<span class="variable">.Condition</span>(condition));</span><br></pre></td></tr></table></figure><p>ctrl和dm在交互，这就导致了输出信号会是<code>XXXXXXXX</code>,所以我们选择在外部译码。虽然我也不知道这么干为什么不行。。。</p><h2 id="CCS"><a href="#CCS" class="headerlink" title="CCS"></a>CCS</h2><p>这个是考试题</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">high_ones = memword[31:16] 1 的个数</span><br><span class="line">low_ones = memword[15:0] 1 的个数</span><br><span class="line">if high_ones &gt; low_ones &#123;</span><br><span class="line">    memword ^ GPR[rt] -&gt; GPR[31]</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    memword -&gt; GPR[high_ones]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目和上一题的区别在于GPR[high_ones]直到M级才知道，因此冲突判断直接无脑置1即可</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> E_stall_rs = ((E_lbget ? <span class="number">1</span> : (E_GRFA3 == D_rs)) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> E_stall_rt = ((E_lbget ? <span class="number">1</span> : (E_GRFA3 == D_rt)) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; E_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rs = ((M_GRFA3 == D_rs) &amp;&amp; D_rs != <span class="number">0</span>) &amp;&amp; (rs_Tuse &lt; M_Tnew);</span><br><span class="line"><span class="keyword">assign</span> M_stall_rt = ((M_GRFA3 == D_rt) &amp;&amp; D_rt != <span class="number">0</span>) &amp;&amp; (rt_Tuse &lt; M_Tnew);</span><br></pre></td></tr></table></figure><p>剩下的操作跟LBGET一样，大家依葫芦画瓢应该问题不大。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>笔者的个人仓库里有P5_pro,实现了<code>BLZTAL</code>,<code>LBGET</code>,<code>BONALL</code>,大家如果真的对自己的bug毫无想法可以参考一下哦😋。</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">你是我的眼</span><br><span class="line">带我领略四季的变换</span><br><span class="line">你是我的眼</span><br><span class="line">带我穿越拥挤的人潮</span><br><span class="line">你是我的眼</span><br><span class="line">带我阅读浩瀚的书海</span><br><span class="line">因为你是我的眼</span><br><span class="line">让我看见</span><br><span class="line">这世界</span><br><span class="line">就在我眼前</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P4课上</title>
      <link href="/2026/01/21/P4%E8%AF%BE%E4%B8%8A/"/>
      <url>/2026/01/21/P4%E8%AF%BE%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><strong>写在前面</strong>：笔者不是大佬，P4二战方过，这里记载了二战题目的comprehensive版本。</p><ul><li>为什么是comprehensive版本？因为做完挺早，等助教问答的时候顺手把题抄了。</li><li>为什么没有一战题目？因为一战没心情回忆痛苦的过去。</li><li>为什么二战如此神速？我也不知道，可能是题简单吧。</li></ul><h2 id="SSZE"><a href="#SSZE" class="headerlink" title="SSZE"></a>SSZE</h2><p>opcode &#x3D; 6’b000000<br>func &#x3D; 6’b001111</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">当GPR[rs]和GPR[rt]后缀 0 的个数相同时，将GPR[rd]置 1 ，否则置 0 ;</span><br></pre></td></tr></table></figure><p><strong>Answer</strong>:重点在数0的个数，还有就是改指令的时候记得把通路改完整(这个以大家对自己verilog代码的理解都不成问题)。</p><h2 id="CABC"><a href="#CABC" class="headerlink" title="CABC"></a>CABC</h2><p>opcode &#x3D; 6’b111100</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cross1 = GPR[rs][23:16] || GPR[rs][7:0] || GPR[rt][31:24] || GPR[rt][15:8]</span><br><span class="line">cross2 = GPR[rt][7:0] || GPR[rt][23:16] || GPR[rs][15:8] || GPR[rs][31:24]</span><br><span class="line">xor_result = cross1 ^ cross2</span><br><span class="line">if (count_zeros(xor_result[31:16]) == count_zeros(xor_result[15:0])) &#123;</span><br><span class="line">    PC &lt;-- IMM_beq</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    GPR[rt] &lt;-- xor_result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Answer</strong>:这和第一题几乎一样，唯一需要注意的是<code>if</code>判断条件成立与否，寄存器堆设计的是<code>是否操作</code>,因此在CTRL模块中的WE(寄存器写使能信号)是(caba &amp;&amp; isequal &#x3D;&#x3D; 0)。isequal是ALU输出的<code>count_zeros(xor_result[31:16]) == count_zeros(xor_result[15:0])</code>判断结果。</p><h2 id="LHBOC"><a href="#LHBOC" class="headerlink" title="LHBOC"></a>LHBOC</h2><p>opcode &#x3D; 101101</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vaddr &lt;-- GPR[base] + sign_extend(offset)</span><br><span class="line">paddr &lt;-- vaddr[31:2] || 2&#x27;b0</span><br><span class="line">memword &lt;-- Memory[paddr]</span><br><span class="line">tmp1 &lt;-- memword[15] + memword[14] + ...... + memword[0]</span><br><span class="line">tmp2 &lt;-- memword[31] + memword[30] + ...... + memword[16]</span><br><span class="line">if (tmp1 &gt; tmp2) &#123;</span><br><span class="line">    GPR[rt] &lt;-- sign_extend(memword[15:0])</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    GPR[rt] &lt;-- sign_extend(memword[31:16])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Answer</strong>:这个题也挺简单的，注意一下不要被RTL语言<strong>骗了</strong>,我们看到这行<code>memword &lt;-- Memory[paddr]</code>,paddr是32位，而DM的范围是<code>0-3072</code>，只需要12位即可，我们在verilog实现的过程中要像这样</p><blockquote><p>memword &#x3D; DM[addr[13:2]];</p></blockquote><p>addr是ALU的输出结果。</p><h2 id="一些Tips"><a href="#一些Tips" class="headerlink" title="一些Tips"></a>一些Tips</h2><ol><li>课下最好实现这个函数——-<strong>sign_extend</strong></li><li>一定要记得有符号数怎么比大小，要不然就上去<code>if</code>手搓吧：<code>$signed(A) &gt; $singned(B)</code></li><li>循环移位别写<code>for</code>循环,会<code>TLE</code>,用这个<code>(A &gt;&gt; n) + (A &lt;&lt; (32 - n))</code></li><li>写函数的时候记得在<code>function</code>后面有<code>begin，end</code>把函数体包起来。</li><li>祝大家P4一战顺利😉😊</li></ol><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">倘若那天</span><br><span class="line">把该说的话好好说</span><br><span class="line">该体谅的不执著</span><br><span class="line">如果那天我</span><br><span class="line">不受情绪挑拨</span><br><span class="line">你会怎么做</span><br><span class="line">那么多如果，可能如果我</span><br><span class="line">可惜没如果，只剩下结果</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>谨以此篇，纪念我的第一篇<code>github</code>博客。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P4课下</title>
      <link href="/2026/01/21/P4%E8%AF%BE%E4%B8%8B/"/>
      <url>/2026/01/21/P4%E8%AF%BE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从P4开始，我们将开始搭建单周期CPU，使用的编程语言仅仅是verilog,并且对于verilog的要求仅限于语法，没有烦人的状态机。所以被P1搞红温的同学可以长舒一口气了😋。</p><h2 id="设计方案综述"><a href="#设计方案综述" class="headerlink" title="设计方案综述"></a>设计方案综述</h2><p>本次实验实现的指令包括add,sub,ori,lw,sw,beq,lui,sll,j,jal,jr,jalr，通过将各个元件模块化封装，再用<code>wire</code>连接，进而封装成完整的CPU。</p><p>整体架构图如下：<br><img src="/images/v%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="整体架构图"></p><p>下面将分模块详细介绍一下设计思路和实现方法。</p><h2 id="关键模块实现"><a href="#关键模块实现" class="headerlink" title="关键模块实现"></a>关键模块实现</h2><h3 id="datapath"><a href="#datapath" class="headerlink" title="datapath"></a>datapath</h3><p>这一部分是除了CTRL之外的元件的集合，相当于顶层模块MIPS的两个子分支之一。其实理论上可以将DM，ALU，CTRL等元件直接揉到一起写成mips.v,但是笔者认为像这样分开来写思路更加清晰条理。</p><p>datapath模块的顶层是将ifu，am，alu等组件封装起来，形成一个对CTRL的接口。代码如下：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> DATAPATH (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] NPCOp,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] WDSel,</span><br><span class="line">    <span class="keyword">input</span> WESel,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] WRA3Sel,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] ALUOp,</span><br><span class="line">    <span class="keyword">input</span> BSel,</span><br><span class="line">    <span class="keyword">input</span> EXTOp,</span><br><span class="line">    <span class="keyword">input</span> DMWr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] opcode,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] func</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先对模块实例化，其次要定义连线，</span></span><br><span class="line">  <span class="comment">// 这里定义的wire是真的wire</span></span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] ifu_pc;</span><br><span class="line">  <span class="keyword">wire</span> ALU_zero;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] instr;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] IFU_npc;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] NPC_pc_4;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] grf_A3;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] grf_WD;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] grf_RD1;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] grf_RD2;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] ALU_C;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] ext_imm;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] ALU_B;</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] dm_rd;</span><br></pre></td></tr></table></figure><p>这里以IFU模块为例说明模块实例化如何实现，请看代码：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">IFU ifu (</span><br><span class="line">    <span class="variable">.NPC</span>(IFU_npc),</span><br><span class="line">    <span class="variable">.PC</span>(ifu_pc),</span><br><span class="line">    <span class="variable">.instruct</span>(instr),</span><br><span class="line">    <span class="variable">.clk</span>(clk),  <span class="comment">//out</span></span><br><span class="line">    <span class="variable">.reset</span>(reset)  <span class="comment">//out</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中IFU_npc代表NPC模块的输出NPC，也是IFU的输入。理论上讲这种格式应该是<strong>括号外</strong>是子模块的端口而<strong>括号内</strong>是父模块的信号。为了方便理解可以把他直观看成一根线，一根连接两个端口的线。</p><h4 id="其他子模块"><a href="#其他子模块" class="headerlink" title="其他子模块"></a>其他子模块</h4><p>剩余子模块相对独立，正常翻译logisim代码即可。</p><p>特别说明，为了方便表示电路中的所有连线，新增MUX模块，端口定义如下：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MUX (</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">4</span>:<span class="number">0</span>] WRA3MUX1,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">4</span>:<span class="number">0</span>] WRA3MUX2,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">4</span>:<span class="number">0</span>] WRA3MUX3,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>] WRA3Sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] A3,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] WDMUX1,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] WDMUX2,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] WDMUX3,</span><br><span class="line">    <span class="keyword">input</span>  [ <span class="number">2</span>:<span class="number">0</span>] WDSel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] WD,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] BMUX1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] BMUX2,</span><br><span class="line">    <span class="keyword">input</span> BSel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] ALU_B</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="CTRL"><a href="#CTRL" class="headerlink" title="CTRL"></a>CTRL</h3><p>ctrl 要实现和datapath对接的接口，内部按照logisim设计时的与或关系来实现即可。</p><h3 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h3><p>mips作为顶层电路，实现的是<code>CTRL</code>模块和<code>DATAPATH</code>模块的的拼接</p><h3 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h3><ul><li>关于连线：在datapath模块的线路拼接中，由于一根线的两端连接的元件一般不同，所以建议在给wire命名时加上相连的某个元件，在写代码时便于识别信号通路。例如<code>wire ALU_zero;</code></li></ul><p>但是在mips中的线路拼接时，由于只有两个元件，因此所有接口都是一一对应关系。子模块端口和父模块信号可以一样，不会混淆。例如</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] func; </span><br><span class="line"></span><br><span class="line">DATAPATH datapath(</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">   <span class="variable">.func</span>(func)     <span class="comment">//out</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CTRL ctrl(</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">   <span class="variable">.func</span>(func)     <span class="comment">//in </span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>关于命名：个人习惯模块名称大写，实例化时的名字小写，例如 <code>DATAPATH datapath</code>。</li></ul><h3 id="Some-Bugs"><a href="#Some-Bugs" class="headerlink" title="Some Bugs"></a>Some Bugs</h3><ol><li>IFU模块中的指令文档命名 <code>code.txt</code></li><li>NPC模块中传入的<code>zero</code>一定仔细考虑好<code>BEQ</code>指令下<code>zero==0</code>和<code>zero!=0</code>的输出分别是什么，千万别搞混</li><li>CTRL模块中的<code>JR</code>和<code>JALR</code>指令有<code>opcode==SPECIAL</code> (一定要记得),并且是<code>opcode</code>不是<code>func</code>。😭</li><li>注意一下在对指令切片时放大logisim仔细瞅瞅，要不然就要硬搓Isim仿真了</li></ol><h2 id="Verilog仿真指南"><a href="#Verilog仿真指南" class="headerlink" title="Verilog仿真指南"></a>Verilog仿真指南</h2><p>verilog的testbench还是较为友好的，只需要开始时reset&#x3D;1，#100后reset &#x3D; 0。</p><p>想要监测指令名称时看波形图<br>想要监测寄存器中的数据时，在 Isim 界面左侧选择 Memory 选项，如图：</p><p><img src="/images/register%E6%9F%A5%E7%9C%8B%E7%A4%BA%E4%BE%8B.png" alt="register查看示例"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li>Q:这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ?</li></ul><p>A:  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addr由ALU计算得到。一条地址占32位2进制，也就是4个字节，截取 [11:2] 相当于将地址右移四位，将地址转换位第n条指令，从而便于在RAM读写。</span><br></pre></td></tr></table></figure><ul><li>Q:<br>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</li></ul><p>A:</p><p>指令对应的控制信号如何取值:</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (add == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        WESel = <span class="number">1</span>;</span><br><span class="line">        WRA3Sel[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>控制信号每种取值对应的指令：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">0</span>] = beq | jalr | jr;</span><br><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">1</span>] = j | jal | jalr | jr;</span><br><span class="line"><span class="keyword">assign</span> NPCOp[<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>优劣对比：</p><ul><li>Q:复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。</li></ul><p>A :</p><p>异步复位：reset信号优先级大于clk</p><p>同步复位：reset信号优先级小于clk</p><ul><li>Q:C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分（详见文档 page 34、page 35）。</li></ul><p>A:</p><p>在MIPS英文指令集中，对于add指令的定义是 <code>ADDU performs the same arithmetic operation but does not trap on overflow.</code>因此addu和add在忽略溢出的前提下是等价的。</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">等不到天黑</span><br><span class="line">烟火不会太完美</span><br><span class="line">回忆烧成灰</span><br><span class="line">还是等不到结尾</span><br><span class="line">他层说的无所谓</span><br><span class="line">我怕一天一天被摧毁</span><br><span class="line">等不到天黑</span><br><span class="line">不敢凋谢的花蕾</span><br><span class="line">雨也在跟随</span><br><span class="line">放开刺痛的滋味</span><br><span class="line">今后不再怕天明</span><br><span class="line">我想只是害怕清醒</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P3课下</title>
      <link href="/2026/01/21/P3%E8%AF%BE%E4%B8%8B/"/>
      <url>/2026/01/21/P3%E8%AF%BE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从P3开始，我们正式开始设计CPU，首先从单周期开始入手，P3使用logisim，并且不会涉及特别复杂的<strong>状态机</strong>，指令也相对容易。</p><h2 id="设计方案综述"><a href="#设计方案综述" class="headerlink" title="设计方案综述"></a>设计方案综述</h2><p>要求实现的指令集包括 add(不考虑溢出), subu(不考虑溢出), ori, lw, sw, beq, lui, nop,j,jal,jr,jalr</p><p>整体架构图如下：<br><img src="/images/%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="整体结构"></p><p>参考了课件中的缩略简图：<br><img src="/images/%E7%BC%A9%E7%95%A5%E5%9B%BE.png" alt="缩略图"></p><h2 id="关键模块的定义"><a href="#关键模块的定义" class="headerlink" title="关键模块的定义"></a>关键模块的定义</h2><h3 id="IFU：由PC-程序计数器-和IM组成"><a href="#IFU：由PC-程序计数器-和IM组成" class="headerlink" title="IFU：由PC(程序计数器)和IM组成"></a>IFU：由PC(程序计数器)和IM组成</h3><h4 id="端口说明："><a href="#端口说明：" class="headerlink" title="端口说明："></a>端口说明：</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>NPC[31:0]</td><td>I</td><td>输入NPC</td></tr><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td>复位信号</td></tr><tr><td>instruct[31:0]</td><td>O</td><td>输出当前指令</td></tr><tr><td>PC[31:0]</td><td>O</td><td>输出当前指令地址</td></tr></tbody></table><h4 id="元件示意图"><a href="#元件示意图" class="headerlink" title="元件示意图"></a>元件示意图</h4><p><img src="/images/IFU%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="IFU元件示意图"></p><p><strong>tips</strong>:尽量将PC和IM分开写，方便调试时观测RAM指令执行的变化</p><h3 id="NPC-次地址计算单元"><a href="#NPC-次地址计算单元" class="headerlink" title="NPC(次地址计算单元)"></a>NPC(次地址计算单元)</h3><h4 id="端口说明"><a href="#端口说明" class="headerlink" title="端口说明"></a>端口说明</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>ra</td><td>I</td><td>rs寄存器中存储的数据</td></tr><tr><td>PC[31:0]</td><td>I</td><td>当前正在执行的指令地址</td></tr><tr><td>zero</td><td>I</td><td><code>$rs</code> 和 <code>$rt</code>是否相等</td></tr><tr><td>npcOp</td><td>I</td><td>控制信号</td></tr><tr><td>imm[25:0]</td><td>I</td><td>用于拼接出NPC</td></tr><tr><td>npc[31:0]</td><td>O</td><td>次地址</td></tr><tr><td>PC+4[31:0]</td><td>O</td><td>当前正在执行的指令地址+4</td></tr></tbody></table><h4 id="控制信号说明"><a href="#控制信号说明" class="headerlink" title="控制信号说明"></a>控制信号说明</h4><ol><li><strong>npcOp</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>3’b000</td><td>PC+4作为次地址</td></tr><tr><td>3’b001</td><td>beq</td></tr><tr><td>3’b010</td><td>j,jal</td></tr><tr><td>3’b011</td><td>jr,jalr</td></tr></tbody></table><h4 id="元件示意图-1"><a href="#元件示意图-1" class="headerlink" title="元件示意图"></a>元件示意图</h4><p><img src="/images/NPC%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="NPC元件示意图"></p><h3 id="GRF-寄存器堆"><a href="#GRF-寄存器堆" class="headerlink" title="GRF(寄存器堆)"></a>GRF(寄存器堆)</h3><h4 id="端口说明：-1"><a href="#端口说明：-1" class="headerlink" title="端口说明："></a>端口说明：</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，将其储存的数据读出到 RD1</td></tr><tr><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，将其储存的数据读出到 RD2</td></tr><tr><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，将其作为写入数据的目标寄存器</td></tr><tr><td>WD[31:0]</td><td>I</td><td>32位数据输入信号，将该数据写入目标寄存器A3</td></tr><tr><td>WE</td><td>I</td><td>写使能</td></tr><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td>复位信号</td></tr><tr><td>RD1[31:0]</td><td>O</td><td>输出A1指定寄存器中的数据</td></tr><tr><td>RD2[31:0]</td><td>O</td><td>输出A2指定寄存器中的数据</td></tr></tbody></table><h4 id="控制信号说明："><a href="#控制信号说明：" class="headerlink" title="控制信号说明："></a>控制信号说明：</h4><ol><li><strong>weSel</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>1’b0</td><td>不可写入</td></tr><tr><td>1’b1</td><td>可写入</td></tr></tbody></table><ol start="2"><li><strong>wrA3Sel[2:0]</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>3’b000</td><td>rt作为写入数据的目标寄存器</td></tr><tr><td>3’b001</td><td>rd作为写入数据的目标寄存器</td></tr><tr><td>3’b010</td><td>$31作为写入数据的目标寄存器</td></tr></tbody></table><ol start="3"><li><strong>WDSel[2:0]</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>3’b000</td><td>写入寄存器的数据来自ALU的运算结果</td></tr><tr><td>3’b001</td><td>写入寄存器的数据来自DM</td></tr><tr><td>3’b010</td><td>写入寄存器的数据是PC+4</td></tr></tbody></table><h4 id="元件示意图："><a href="#元件示意图：" class="headerlink" title="元件示意图："></a>元件示意图：</h4><p><img src="/images/GRF%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="GRF元件示意图"></p><h3 id="ALU-算数逻辑单元"><a href="#ALU-算数逻辑单元" class="headerlink" title="ALU(算数逻辑单元)"></a>ALU(算数逻辑单元)</h3><h4 id="端口说明-1"><a href="#端口说明-1" class="headerlink" title="端口说明"></a>端口说明</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>A[31:0]</td><td>I</td><td>运算数A</td></tr><tr><td>B[31:0]</td><td>I</td><td>运算数B</td></tr><tr><td>shamt[4:0]</td><td>I</td><td>sll的位数</td></tr><tr><td>ALUOp[2:0]</td><td>I</td><td>控制信号</td></tr><tr><td>C[31:0]</td><td>O</td><td>运算输出结果</td></tr><tr><td>zero</td><td>O</td><td>A和B是否相等</td></tr></tbody></table><h4 id="控制信号说明-1"><a href="#控制信号说明-1" class="headerlink" title="控制信号说明"></a>控制信号说明</h4><ol><li><strong>ALUOp[2:0]</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>3’b000</td><td>add</td></tr><tr><td>3’b001</td><td>sub</td></tr><tr><td>3’b010</td><td>ori</td></tr><tr><td>3’b011</td><td>lui</td></tr><tr><td>3’b100</td><td>sll</td></tr></tbody></table><ol start="2"><li><strong>BSel</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>1’b0</td><td>B的值为<code>$rt</code></td></tr><tr><td>1’b1</td><td>B的值为imm</td></tr></tbody></table><h4 id="元件示意图-2"><a href="#元件示意图-2" class="headerlink" title="元件示意图"></a>元件示意图</h4><p><img src="/images/ALU%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ALU元件示意图"></p><h3 id="DM-数据存储器"><a href="#DM-数据存储器" class="headerlink" title="DM (数据存储器)"></a>DM (数据存储器)</h3><h4 id="端口说明-2"><a href="#端口说明-2" class="headerlink" title="端口说明"></a>端口说明</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>addr[31:0]</td><td>I</td><td>待操作的内存地址</td></tr><tr><td>WD[31:0]</td><td>I</td><td>待写入的内存值</td></tr><tr><td>WR</td><td>I</td><td>写使能信号</td></tr><tr><td>clk</td><td>I</td><td>时钟信号</td></tr><tr><td>reset</td><td>I</td><td>复位信号</td></tr><tr><td>RD[31:0]</td><td>O</td><td>输入地址指向的内存中存储的值</td></tr></tbody></table><h4 id="控制信号说明-2"><a href="#控制信号说明-2" class="headerlink" title="控制信号说明"></a>控制信号说明</h4><ol><li><strong>WR</strong></li></ol><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>1’b0</td><td>不能写入</td></tr><tr><td>1’b1</td><td>可以写入</td></tr></tbody></table><h4 id="元件示意图-3"><a href="#元件示意图-3" class="headerlink" title="元件示意图"></a>元件示意图</h4><p><img src="/images/DM%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="DM元件示意图"></p><h3 id="EXT-位扩展"><a href="#EXT-位扩展" class="headerlink" title="EXT(位扩展)"></a>EXT(位扩展)</h3><h4 id="端口说明-3"><a href="#端口说明-3" class="headerlink" title="端口说明"></a>端口说明</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>imm</td><td>I</td><td>输入待扩展的立即数</td></tr><tr><td>extOp</td><td>I</td><td>控制信号</td></tr><tr><td>extend</td><td>O</td><td>位扩展后的结果</td></tr></tbody></table><h4 id="控制信号说明-3"><a href="#控制信号说明-3" class="headerlink" title="控制信号说明"></a>控制信号说明</h4><table><thead><tr><th>控制信号值</th><th>功能</th></tr></thead><tbody><tr><td>1’b0</td><td>0扩展</td></tr><tr><td>1’b1</td><td>符号扩展</td></tr></tbody></table><h4 id="元件示意图-4"><a href="#元件示意图-4" class="headerlink" title="元件示意图"></a>元件示意图</h4><p><img src="/images/EXT%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="EXT元件示意图"></p><h3 id="CTRL-控制信号模块"><a href="#CTRL-控制信号模块" class="headerlink" title="CTRL(控制信号模块)"></a>CTRL(控制信号模块)</h3><h4 id="端口说明-4"><a href="#端口说明-4" class="headerlink" title="端口说明"></a>端口说明</h4><table><thead><tr><th>信号名称</th><th>方向</th><th>功能描述</th></tr></thead><tbody><tr><td>OPcode[5:0]</td><td>I</td><td>输入标识信号</td></tr><tr><td>FuncCode[5:0]</td><td>I</td><td>输入标识信号</td></tr><tr><td>NPCOp[2:0]</td><td>O</td><td>npc计算方式</td></tr><tr><td>WDSel[2:0]</td><td>O</td><td>GRF存的数据</td></tr><tr><td>WeSel</td><td>O</td><td>GRF写使能</td></tr><tr><td>WRA3Sel[2:0]</td><td>O</td><td>GRF写入地址</td></tr><tr><td>ALUOp[2:0]</td><td>O</td><td>ALU模式</td></tr><tr><td>Bsel</td><td>O</td><td>B的数据类型</td></tr><tr><td>extOp</td><td>O</td><td>有&#x2F;无符号扩展</td></tr><tr><td>DMWR</td><td>O</td><td>DM写使能</td></tr></tbody></table><h4 id="元件示意图-5"><a href="#元件示意图-5" class="headerlink" title="元件示意图"></a>元件示意图</h4><p><img src="/images/CTRL%E5%85%83%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CTRL元件示意图"></p><h2 id="RTL指令"><a href="#RTL指令" class="headerlink" title="RTL指令"></a>RTL指令</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. add: GPR[rd] &lt;- GPR[rs]+GPR[rt]</span><br><span class="line">2. sub: GPR[rd] &lt;- GPR[rs] - GPR[rt]</span><br><span class="line">3. ori: GPR[rt] &lt;- GPR[rs] OR immediate</span><br><span class="line">4. lw: GPR[rt] &lt;- memory[GPR[base]+offset]</span><br><span class="line">5. sw: memory[GPR[base]+offset] &lt;- GPR[rt]</span><br><span class="line">6. beq: if (GPR[rs] == GPR[rt]) then 转移</span><br><span class="line">7. lui: GPR[rt] &lt;- immediate&#123;16&#123;0&#125;&#125;</span><br><span class="line">8. sll: GPR[rd] &lt;- GPR[rt] &lt;&lt; s</span><br><span class="line">9. j : PC &lt;- PC31..28 || instr_index || 00</span><br><span class="line">10. jal: PC &lt;- PC31..28 || instr_index || 00</span><br><span class="line">    GPR[31] &lt;- PC + 4</span><br><span class="line">11. jalr: PC &lt;- GPR[rs]</span><br><span class="line">    GPR[rd] &lt;- PC + 4</span><br><span class="line">12. jr: PC &lt;- GPR[rs]</span><br></pre></td></tr></table></figure><h2 id="数据通路分析"><a href="#数据通路分析" class="headerlink" title="数据通路分析"></a>数据通路分析</h2><table><thead><tr><th align="center">指令</th><th align="center">opcode</th><th align="center">funct</th><th align="center">npcOp</th><th align="center">WDSel</th><th align="center">weSel</th><th align="center">wrA3Sel</th><th align="center">ALUOp</th><th align="center">BSel</th><th align="center">extOp</th><th align="center">WR</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">instruct[26:21]</td><td align="center">instruct[5:0]</td><td align="center">npc计算方式</td><td align="center">GRF存的数据</td><td align="center">GRF写使能</td><td align="center">GRF写入地址</td><td align="center">ALU模式</td><td align="center">B的数据类型</td><td align="center">有&#x2F;无符号扩展</td><td align="center">DM写使能</td></tr><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td><td align="center">000</td><td align="center">000</td><td align="center">1</td><td align="center">001</td><td align="center">000</td><td align="center">0</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td><td align="center">000</td><td align="center">000</td><td align="center">1</td><td align="center">001</td><td align="center">001</td><td align="center">0</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center">x</td><td align="center">000</td><td align="center">000</td><td align="center">1</td><td align="center">000</td><td align="center">010</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center">x</td><td align="center">000</td><td align="center">001</td><td align="center">1</td><td align="center">000</td><td align="center">000</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center">x</td><td align="center">000</td><td align="center">x</td><td align="center">0</td><td align="center">x</td><td align="center">000</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center">x</td><td align="center">001</td><td align="center">x</td><td align="center">0</td><td align="center">x</td><td align="center">001</td><td align="center">0</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center">x</td><td align="center">000</td><td align="center">000</td><td align="center">1</td><td align="center">000</td><td align="center">011</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">sll</td><td align="center">000000</td><td align="center">000000</td><td align="center">000</td><td align="center">000</td><td align="center">1</td><td align="center">001</td><td align="center">100</td><td align="center">0</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">j</td><td align="center">000010</td><td align="center">x</td><td align="center">010</td><td align="center">x</td><td align="center">0</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">jal</td><td align="center">000011</td><td align="center">x</td><td align="center">010</td><td align="center">010</td><td align="center">1</td><td align="center">010</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">jalr</td><td align="center">001001</td><td align="center">x</td><td align="center">011</td><td align="center">010</td><td align="center">1</td><td align="center">001</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">jr</td><td align="center">001000</td><td align="center">x</td><td align="center">011</td><td align="center">x</td><td align="center">0</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">0</td></tr></tbody></table><p><strong>PS</strong>:</p><ol><li>在课下设计时尽可能将控制信号设为<strong>3位</strong>或<strong>2位</strong>，这样在课上考试时就不需要使用实验室逆天鼠标来完成这一部分工作了。</li><li>课下设计尽可能留足扩展空间，不要画的太密，否则考场红温时无疑是雪上加霜😨。</li></ol><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="测试ori指令"><a href="#测试ori指令" class="headerlink" title="测试ori指令"></a>测试ori指令</h3><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ori </span>$<span class="number">0</span>, $<span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>, $<span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">2</span>, $<span class="number">2</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">3</span>, $<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">4</span>, $<span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">5</span>, $<span class="number">5</span>, <span class="number">5</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">6</span>, $<span class="number">6</span>, <span class="number">6</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">7</span>, $<span class="number">7</span>, <span class="number">7</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">8</span>, $<span class="number">8</span>, <span class="number">8</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">9</span>, $<span class="number">9</span>, <span class="number">9</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">10</span>, $<span class="number">10</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">11</span>, $<span class="number">11</span>, <span class="number">11</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">12</span>, $<span class="number">12</span>, <span class="number">12</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">13</span>, $<span class="number">13</span>, <span class="number">13</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">14</span>, $<span class="number">14</span>, <span class="number">14</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">15</span>, $<span class="number">15</span>, <span class="number">15</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">16</span>, $<span class="number">16</span>, <span class="number">16</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">17</span>, $<span class="number">17</span>, <span class="number">17</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">18</span>, $<span class="number">18</span>, <span class="number">18</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">19</span>, $<span class="number">19</span>, <span class="number">19</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">20</span>, $<span class="number">20</span>, <span class="number">20</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">21</span>, $<span class="number">21</span>, <span class="number">21</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">22</span>, $<span class="number">22</span>, <span class="number">22</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">23</span>, $<span class="number">23</span>, <span class="number">23</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="number">24</span>, $<span class="number">24</span>, <span class="number">24</span></span><br></pre></td></tr></table></figure><p>在MIPS中运行出结果以后在logisim中的GRF查看</p><h3 id="测试sw指令"><a href="#测试sw指令" class="headerlink" title="测试sw指令"></a>测试sw指令</h3><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>, $<span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">4</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">8</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">12</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">16</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">20</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">24</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">28</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">32</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">36</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">40</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">44</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">48</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">52</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">56</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">60</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">64</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">68</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">72</span>($<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>在logisim中的DM中查看</li><li>偏移量范围是 -2^15 ～ 2^15 - 1</li><li>跟寄存器没关系，涉及的是DM只是用了寄存器中的值</li></ul><h3 id="测试lw"><a href="#测试lw" class="headerlink" title="测试lw"></a>测试lw</h3><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ori </span>$<span class="number">1</span>, $<span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="number">1</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">2</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">3</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">4</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">5</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">6</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">7</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">8</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">9</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">10</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">11</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">12</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">13</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">14</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">15</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">16</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">17</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">18</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line"><span class="keyword">lw </span>$<span class="number">19</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>先用之前测出的or，sw，然后再用lw往出导，导出到不同的寄存器里面,在logisim中的GRF查看</p><h3 id="测试lui"><a href="#测试lui" class="headerlink" title="测试lui"></a>测试lui</h3><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lui </span>$<span class="number">0</span>，<span class="number">0</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">2</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="number">3</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><p>在logisim中的GRF查看，与MIPS的运行结果做对照</p><h3 id="测试addu，subu，beq，nop"><a href="#测试addu，subu，beq，nop" class="headerlink" title="测试addu，subu，beq，nop"></a>测试addu，subu，beq，nop</h3><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ori </span> $<span class="number">1</span>, $<span class="number">1</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">ori </span> $<span class="number">2</span>, $<span class="number">2</span>, <span class="number">20</span></span><br><span class="line"><span class="keyword">addu </span>$<span class="number">3</span>, $<span class="number">1</span>, $<span class="number">1</span></span><br><span class="line"><span class="keyword">addu </span>$<span class="number">4</span>, $<span class="number">1</span>, $<span class="number">2</span></span><br><span class="line"><span class="keyword">subu </span>$<span class="number">5</span>, $<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line"><span class="keyword">subu </span>$<span class="number">6</span>, $<span class="number">1</span>, $<span class="number">1</span></span><br><span class="line"><span class="keyword">lui </span> $<span class="number">4</span>, <span class="number">0xffff</span> </span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beq </span> $<span class="number">1</span>, $<span class="number">0</span>, end</span><br><span class="line"><span class="keyword">lui </span> $<span class="number">1</span>, <span class="number">0xffff</span></span><br><span class="line"><span class="symbol">end:</span></span><br></pre></td></tr></table></figure><p>这里因为addu和add的Opcode不同，sub同理，所以在导出之前需要将addu，subu全部转成add，sub，但是MIPS运行仍然使用addu和subu</p><p>将MIPS的DM导出，与logisim的DM导出信息做对照，如果相同则证明程序正确。</p><p>当然以上只是小规模测试，如需广泛测试需要借助python自动生成MIPS代码，进而通过git diff做比较 <strong>(在大规模测试下其实只需要比较DM即可，无需对GRF进行对拍)</strong> ，或者通过python程序进行比较。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</li></ul><blockquote><p>状态存储：IM GRF DM<br>状态转移： NPC ALU</p></blockquote><ul><li>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</li></ul><blockquote><p>IM 只会被读取，其中的值不用修改，使用ROM合理<br>DM 需要读取和写入，可以使用RAM和Register。但是DM要求的内存是3072的空间，使用Register的话可能手绘有一定困难<br>GRF频繁读写指令，Register可以保证读写速度</p></blockquote><ul><li>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</li></ul><blockquote><p>实现了sll。sll是将<code>$rt</code>寄存器中的值左移shamt位放到<code>$rd</code>中，因此需要在ALU模块新增shamt输入，在CTRL中实现此时wrA3Sel&#x3D;1，weSel&#x3D;1,BSel &#x3D; 0</p></blockquote><ul><li>事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？</li></ul><blockquote><ol><li>nop指令会被识别成R型指令，<code>$rs,$rt,$rd</code>均为0号寄存器，而0号寄存器的值恒为0，因此不需要特殊处理。</li><li>该CPU设计实现了sll，nop指令相当于 <code>sll $0 $0 0</code>,相当于把$0寄存器中的值左移0位并写入<code>$0</code>寄存器，因为<code>$0</code>的值始终为0，不会被修改，因此该指令执行后没有任何影响。</li></ol></blockquote><ul><li>阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</li></ul><blockquote><p>lw 和 sw指令没有覆盖offset为负数的情况<br>没有测试nop和sub指令</p></blockquote><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">他字字未提喜欢你</span><br><span class="line">你句句都是我愿意</span><br><span class="line">他一句寂寞时候的回应</span><br><span class="line">你却激动不已</span><br><span class="line">他次次回避着话题</span><br><span class="line">你傻傻热情地贴近</span><br><span class="line">穿过多少城市为了他</span><br><span class="line">只因为他</span><br><span class="line">淋湿了自己</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> logisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P3课上</title>
      <link href="/2026/01/21/P3%E8%AF%BE%E4%B8%8A/"/>
      <url>/2026/01/21/P3%E8%AF%BE%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>P3课上考试加的指令都比较常规，个人认为P3考试最大的难点就是机房的鼠标。我只能劝你手别抖了😨。</p><h2 id="一些前置知识"><a href="#一些前置知识" class="headerlink" title="一些前置知识"></a>一些前置知识</h2><p>开始P3之后，你所了解的用于P0的元件已经不够用了，下面列举几个新的P3课上常用的元件。</p><ol><li>Bit Adder:输入一个n位二进制数，输出总共有几位1。</li><li>Bit Finder:输入一个n位二进制数，输出最低位的1&#x2F;最高位的1&#x2F;最低位的0&#x2F;最高位的0的index，还有一个输出端口代表n位二进制数是否含有1。</li><li>Shifter：输入一个数以及移动的位数，输出得到的结果</li></ol><h2 id="rev"><a href="#rev" class="headerlink" title="rev"></a>rev</h2><p>题目：将GPR[rt] 的高index位翻转后放到低位，剩下的位数顺序排列到高位。然后将结果写到GPR[rt]</p><p>解：先将GPR[rt]用<code>splitter</code>整体翻转，再左移+右移得到<code>0000...0+高index位反转结果</code>，和GPR[rt]左移得到的<code>剩余位数+000...000</code><br>相加就可以得到结果。总的来说就是位数转换都可以通过移位操作来实现。</p><h2 id="blz"><a href="#blz" class="headerlink" title="blz"></a>blz</h2><p>题目：大概是数出GPR[rs] GPR[rt]的前导零的数量，然后比大小决定NPC的操作，以及向GRF写入tmp1或tmp2</p><p>解：<strong>重点在数前导0</strong>，用<code>bit Finder</code>时记得考虑没有1的情况。</p><h2 id="lwf"><a href="#lwf" class="headerlink" title="lwf"></a>lwf</h2><p>题目：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lwf base rt offset</span><br><span class="line">从offset(base)的内存中读出一个数据 </span><br><span class="line">判断这个数和rt的and的各个数位之和的奇偶性 </span><br><span class="line">奇数则存入(rt+1)mod32寄存器 </span><br><span class="line">偶数则存入rt寄存器</span><br></pre></td></tr></table></figure><p>解：<strong>重点在奇偶比较</strong>，比较最低位即可。最低位为0是偶数，为1是奇数。</p><p><a href="https://github.com/Cordial-Kid/BUAA-CO/blob/main/P3/%E5%8D%95%E5%91%A8%E6%9C%9FCPU_in_class.circ">github仓库</a>里为大家提供了这三道题目的代码：</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">谁与我画明月天地间</span><br><span class="line">落笔话呢喃</span><br><span class="line">谁遇我南山望北川</span><br><span class="line">扶摇向九天</span><br><span class="line">谁予我谈笑伴云轩</span><br><span class="line">知己醉桌前</span><br><span class="line">任我清风眠</span><br><span class="line">梦回世外仙</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> logisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P2</title>
      <link href="/2026/01/20/P2%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2026/01/20/P2%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>P2主要是对mips指令集架构的理解，重点考察的也就是一些常见的指令，语法上不会像verilog一样坑人，只要是Copre下了点功夫的问题都不大。P2课下可能直接上手汇编代码比较轻松，但是P2在上机的时候一般会给出C语言代码，这个时候不管你看不看得懂，<strong>照着人肉汇编就对了</strong>，千万别自己乱创造。</p><h2 id="关于递归"><a href="#关于递归" class="headerlink" title="关于递归"></a>关于递归</h2><p>递归一般是考试的最后一题，我的建议是大家提前写好push和pop的宏，然后直接照着C代码翻译就行了。递归的关键点在于保存现场和恢复现场。但是教程中说的那个caller调用和callee调用我是真的不懂什么意思，反正我就是直接把所有用到的寄存器都push一遍，函数返回前全部pop回来就完事了，反正也没说要节省空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>细细想来，好像没什么好说的，大家可以去看笔者的<a href="https://github.com/Cordial-Kid/BUAA-CO/tree/main/P2">github仓库</a>,里面有P2的上机测试题目和参考答案，大家可以参考学习。(尤其是Factory,涉及大数乘法)</p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">后来我学会浪漫</span><br><span class="line">学会打扮自己的脸</span><br><span class="line">可距离我想讨你欢心</span><br><span class="line">已过了很多年</span><br><span class="line">你好像站在那段岁月看了我一眼</span><br><span class="line">就把我永远困在遗憾里面</span><br><span class="line">后来我偶尔也会</span><br><span class="line">打听你在谁的身边</span><br><span class="line">只是我再也不能冲动</span><br><span class="line">跑去见你一面</span><br><span class="line">想赢的那场比赛结束在很久以前</span><br><span class="line">最好的你和最好的我之间</span><br><span class="line">只能挥挥手告别</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P1</title>
      <link href="/2026/01/20/P1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2026/01/20/P1%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>P1主要是对verilog在预习阶段所学内容的强化，但是显然没有预习阶段的题目那么恶心。P1的题目大致可以分为两类：一类是组合逻辑电路的设计，另一类是时序逻辑电路状态机的设计。下面分别进行说明。</p><h2 id="组合逻辑电路设计"><a href="#组合逻辑电路设计" class="headerlink" title="组合逻辑电路设计"></a>组合逻辑电路设计</h2><p>组合逻辑电路的设计相对简单，主要考察对verilog语法的掌握以及对基本逻辑电路的理解。说白了就是程序设计换一种语言写而已，不会用很难的算法为难大家的。</p><h2 id="时序逻辑电路状态机设计"><a href="#时序逻辑电路状态机设计" class="headerlink" title="时序逻辑电路状态机设计"></a>时序逻辑电路状态机设计</h2><p>状态机的设计相对复杂一些，主要考察对状态机原理的理解以及verilog实现状态机的能力。状态机的设计一般分为以下5个模块：</p><ol><li>变量定义模块</li><li>initial模块</li><li>时序逻辑状态转移模块</li><li>组合逻辑次态计算模块</li><li>组合逻辑输出计算模块</li></ol><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 变量定义模块</span></span><br><span class="line"><span class="keyword">reg</span> [n-<span class="number">1</span>:<span class="number">0</span>] state; <span class="comment">// 当前状态</span></span><br><span class="line"><span class="keyword">reg</span> [n-<span class="number">1</span>:<span class="number">0</span>] next_state; <span class="comment">// 下一个状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. initial模块</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>  </span><br><span class="line">    state = INITIAL_STATE; <span class="comment">// 初始化状态</span></span><br><span class="line">    next_state = INITIAL_STATE; <span class="comment">// 初始化下一个状态</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 时序逻辑状态转移模块</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        state &lt;= INITIAL_STATE; <span class="comment">// 复位状态</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        state &lt;= next_state; <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 组合逻辑次态计算模块</span></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state)</span><br><span class="line">        STATE_0: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (input_condition) <span class="keyword">begin</span></span><br><span class="line">                next_state = STATE_1;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                next_state = STATE_0;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        STATE_1: <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 其他状态转移逻辑</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 其他状态...</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            next_state = INITIAL_STATE; <span class="comment">// 默认状态</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 组合逻辑输出计算模块</span></span><br><span class="line"><span class="keyword">always</span> @(state) <span class="keyword">begin</span>   </span><br><span class="line">    out = (state == TARGET_STATE) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>; <span class="comment">// 输出逻辑</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>掌握了这个基本框架之后你的状态机就不会经常因为时序问题出bug了。同样的，状态机的设计也可以分为两种方法：一种是使用真值表表示状态机，另一种是使用常规逻辑表达式表示状态机。按照另一种分类方式，可以分为Moore型和Mealy型状态机设计。思路跟P0大同小异，再套用上述提到的模板即可。笔者帮大家整理好了对比代码，上传到了<a href="https://github.com/Cordial-Kid/BUAA-CO/tree/main/P1/Moore_and_Mealy">github仓库</a>，大家可以参考理解，重点关注一下组合逻辑输出计算模块的区别。下面我们重点讲一下状态机Plus版–一般用在<strong>string stream</strong>中，对应上机考试的最后一题。</p><h2 id="状态机的Plus版"><a href="#状态机的Plus版" class="headerlink" title="状态机的Plus版"></a>状态机的Plus版</h2><p>Plus版一般是指在一个模块中设计两个相互独立但又有联系的状态机。举个例子：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">给定按时钟输入的 ASCII 字符流，其中包含若干个由 &quot;&#123;&quot; 与 &quot;&#125;&quot; 包围的简化 JSON 对象（对象之间由空格分隔）。每个键值对的键和值均用双引号包围 &quot;key&quot;:&quot;value&quot;。若对象中出现空字符串键或空字符串值（即 &quot;&quot;），则该对象非法，字段数记为 0。计算每个对象的字段数输出到 cur_num，并维护历史最大合法字段数输出到 max_num。</span><br></pre></td></tr></table></figure><p>这是一道上机考试回忆版题目，可能有的细节不甚详尽，还请大家多多包涵。</p><p>本题的解题思路是在一个模块中设计两个状态机：一个状态机用于维护”IDLE”、”READ”、”CHECK”三个状态，识别JSON对象的开始和结束，第二个状态机负责统计字段数并更新最大值。这里重点和难点是第二个状态机的设置。</p><p>我们用变量number1来统计<code>&quot;</code>的数量，用tmp_cnt来统计两个引号之间的字段数，用cur_num来记录当前对象的字段数，用max_num来记录历史最大字段数。当number1为偶数时，如果tmp_cnt为0，说明出现了空字符串键或空字符串值，此时cur_num置0；否则cur_num加1。每当遇到<code>&#125;</code>时，比较cur_num和max_num的大小，更新max_num。</p><p>详细代码实现参见个人GitHub仓库：<a href="https://github.com/Cordial-Kid/BUAA-CO/blob/main/P1/json.v">https://github.com/Cordial-Kid/BUAA-CO/blob/main/P1/json.v</a></p><h2 id="可能踩的坑"><a href="#可能踩的坑" class="headerlink" title="可能踩的坑"></a>可能踩的坑</h2><p>在只有在组合逻辑电路中才能实现<code>sum = sum + i</code>这类型的语句，在时序逻辑电路中是不允许的。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    sum = <span class="number">0</span>;    <span class="comment">//这一步很重要</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">若不是你突然闯进 我生活</span><br><span class="line">我怎会把死守的寂寞 放任了</span><br><span class="line">爱我的话你都说</span><br><span class="line">爱我的事你不做</span><br><span class="line">我却把甜言蜜语</span><br><span class="line">当作你爱我的躯壳</span><br><span class="line">你的悲伤难过我不参破</span><br><span class="line">我也会把曾今的且过 当施舍</span><br><span class="line">不去计较你太多</span><br><span class="line">从此你在我心里</span><br><span class="line">只剩绿色</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 P0</title>
      <link href="/2026/01/20/P0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2026/01/20/P0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么没有pre？因为pre的题对于我这样的小白来说还是太难了，而且后续也不会重点考察，个人认为没有什么参考价值。</p><p>P0是对预习过程中的logisim的强化练习。我觉得可以大概分成两个部分。一部分是执行自定义指令，例如画一个电路图实现一个32位二进制数的某几位的反转。另一部分是状态机的搭建。下面分两部分陈述。</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>自定义指令的题目其实并不难，主要是考察你对logisim中各种元件的使用。个人觉得比较重要的几个元件有：</p><ul><li>多路选择器（MUX）</li><li>Splitter</li><li>Bit Extender</li><li>组合逻辑门（AND, OR, NOT, XOR等）</li><li>加法器（Adder）</li><li>Bit Selector</li><li>Comparator</li></ul><p>以上这些元件在预习过程中应当做到较为熟练地掌握。虽然并不全面，但是足以让你应对P0中的自定义指令题目。在做题时看清题意，按照题目要求一步一步设计即可，不需要过于复杂的设计思路。</p><h2 id="状态机设计"><a href="#状态机设计" class="headerlink" title="状态机设计"></a>状态机设计</h2><p>状态机的设计有相对固定的套路，只要熟悉了套路状态机简直就在送分。首先要明确的是，状态机分为<strong>Moore型</strong>和<strong>Mealy型</strong>两种。<strong>Moore型</strong>状态机的输出仅与当前状态有关，而<strong>Mealy型</strong>状态机的输出与当前状态和输入均有关。同一个问题两种设计方式都可以，但是在设计时要根据题目要求选择合适的状态机类型。</p><p>理论上来说所有的状态机类型题目都可以用真值表来解决，但是对于某些状态较多的题目来说，真值表会变得非常庞大，不易处理。此时我们可以用<strong>正常的逻辑</strong>来表示现态到次态的转化以及输出的生成。</p><p>同时，电路图大致可分为4个模块。</p><ol><li>Tunnel Module：负责接收输入信号并进行初步处理。</li><li>calculate next state Module：负责根据当前状态和输入信号计算下一个状态。</li><li>state storage Module：负责存储当前状态，通常使用Register实现。</li><li>output Module：负责根据当前状态和输入信号生成输出信号。</li></ol><p>我们以经典的推箱子问题为例说明：大致要求就是从初始状态出发，通过一系列操作将箱子推到目标位置。途中如果碰到障碍物或越界就算失败。</p><p><img src="/images/%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%94%B5%E8%B7%AF%E5%9B%BE.png" alt="推箱子电路图"></p><h3 id="可用真值表表示的状态机"><a href="#可用真值表表示的状态机" class="headerlink" title="可用真值表表示的状态机"></a>可用真值表表示的状态机</h3><p>设计时一般遵循以下步骤：</p><ol><li><strong>明确状态及其编码</strong>：这里要根据题目要求确定状态的数量，并为每个状态分配一个唯一的二进制编码。</li><li><strong>绘制状态转移图</strong>：根据题目描述，绘制状态转移图，明确各状态之间的转移关系以及对应的输入条件。</li><li><strong>编写状态转移表</strong>：将状态转移图转换为状态转移表，列出每个状态在不同输入条件下的下一个状态。</li><li><strong>设计逻辑电路</strong>：根据状态转移表，设计组合逻辑电路来实现<strong>状态转移</strong>和<strong>输出</strong>逻辑。这里可以直接利用logisim内置的真值表工具来实现组合电路。具体步骤如下：</li></ol><p><code>project</code> –&gt; <code>Analyze Circuit</code> –&gt; <code>Input &amp; Output &amp; Table</code> –&gt; <code>填写输入输出变量及真值表</code> –&gt; <code>Generate Circuit</code></p><p>典型例子有：红绿灯控制器。</p><p><img src="/images/%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%AC%A1%E6%80%81%E9%80%BB%E8%BE%91%E8%AE%A1%E7%AE%97%E5%9B%BE.png" alt="红绿灯次态逻辑计算图"><br><img src="/images/%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%AC%A1%E6%80%81%E9%80%BB%E8%BE%91%E7%9C%9F%E5%80%BC%E8%A1%A8.png" alt="红绿灯次态逻辑真值表"><br>输出逻辑计算同理，在此不再赘述。</p><h3 id="常规逻辑表达式表示的状态机"><a href="#常规逻辑表达式表示的状态机" class="headerlink" title="常规逻辑表达式表示的状态机"></a>常规逻辑表达式表示的状态机</h3><p>设计不便于使用真值表的状态机时，就用最原始的，最正常的逻辑思路来计算下一状态即可。</p><p>典型例子有：推箱子。</p><p><img src="/images/%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%AC%A1%E6%80%81%E9%80%BB%E8%BE%91%E8%AE%A1%E7%AE%97%E5%9B%BE.png" alt="推箱子次态逻辑计算图"></p><p>要注意的是次态逻辑的存储时要对次态逻辑的有效性进行判断，例如推箱子中如果出现了碰墙或者越界的情况，次态就不更新，保持不变。这就需要用到多路选择器来选择下一个<code>x</code>到底是<code>x_next</code>还是<code>x_current</code>。</p><h3 id="关于Moore型和Mealy型"><a href="#关于Moore型和Mealy型" class="headerlink" title="关于Moore型和Mealy型"></a>关于Moore型和Mealy型</h3><p><strong>Moore型</strong>和<strong>Mealy型</strong>的状态转移图有很大区别，因为<strong>Mealy型</strong>状态机输出不仅和当前状态有关还和输入有关，因此<strong>Mealy型</strong>状态机中的状态通常比<strong>Moore型</strong>状态机少一个（少的一般是<strong>Moore型</strong>状态机的最后一个状态）。这在真值表中体现为输入影响输出，在状态转移图中体现为输出从<strong>在方框内表示</strong>转化为<strong>在边上表示</strong>。</p><p>如果你使用的是<strong>真值表表示</strong>方法，那么要修改<code>次态转移逻辑</code>和<code>输出逻辑</code>的真值表。次态转移逻辑减少状态，输出逻辑增加<code>input signal</code>作为输入变量。</p><p>如果你使用的是<strong>常规逻辑表达式</strong>的方法，那么不要动<code>次态逻辑计算</code>的设计，只需要修改<code>输出逻辑</code>的设计即可。输出逻辑要使用<code>next state</code>（注意不是<code>current state</code>,也没有<code>input signal</code>）来作为该板块的输入计算输出。</p><h2 id="一些可能的盲区"><a href="#一些可能的盲区" class="headerlink" title="一些可能的盲区"></a>一些可能的盲区</h2><ol><li><strong>异步复位和同步复位</strong>：异步复位是指复位信号一旦被触发，无论时钟信号的状态如何，电路都会立即进入复位状态。而同步复位则是指复位信号只有在时钟信号的上升沿（或下降沿）到来时才会生效。在设计状态机时要根据题目要求选择合适的复位方式。他们的实现方式也不尽相同。</li></ol><p><img src="/images/%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D.png" alt="异步复位"><br><img src="/images/%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D.png" alt="同步复位"></p><ol start="2"><li><strong>“异步”置位和同步置位</strong>：同步置位则是指置位信号只有在时钟信号的上升沿（或下降沿）到来时才会生效。而“异步”置位跟字面意思不太一样，我们要求<code>reset</code>信号在<code>clk</code>信号为低电平时拉高，在<code>clk</code>信号高电平时接地，同时要求<code>clk</code>信号为高电平时能够在<code>register</code>中存储<code>reset</code>信号为高电平时希望设置的值。同步置位的实现方式和同步复位的方式类似，但是“异步”置位的实现就和异步复位大不相同了。</li></ol><p>因为<code>reset</code>信号的转瞬即逝，我们希望有某个模块可以留住<code>reset</code>的效果，<code>Counter</code>成为了最佳选项。电路连接如下图：</p><p><img src="/images/%E2%80%9C%E5%BC%82%E6%AD%A5%E2%80%9D%E7%BD%AE%E4%BD%8D.png" alt="“异步”置位"></p><p>我们将<code>Counter</code>模块的<code>Data bits</code>设置为1位，<code>Action on overflow</code>设置为<code>Stay at value</code>,再将<code>cnt</code>作为选择信号来选择存入<code>register</code>的数据来源。我们分析可以得出，当<code>reset</code>为低电平时，除了初态，所有的状态<code>cnt</code>均为1。当<code>reset</code>为高电平时，<code>cnt</code>变为0。即使此时<code>reset</code>信号转为低电平，<code>cnt</code>依然保持0。因此在clk上升沿时，register模块存入的数据始终为<strong>x</strong>，从而实现了“异步”置位的效果。</p><p>同步置位就很简单了，如下图：<br><img src="/images/%E5%90%8C%E6%AD%A5%E7%BD%AE%E4%BD%8D.png" alt="同步置位"></p><ol start="3"><li>多个数比大小</li></ol><p>在设计多个数比大小的逻辑时，可以使用多个<code>Comparator</code>模块进行两两比较，然后将比较结果进行综合处理。这里需要用到分类讨论的知识。分类讨论的结果可以可以作为多路选择器的待选择信号，比较结果可以作为选择信号，从而实现不同情况下的输出。</p><p><img src="/images/%E4%B8%89%E4%B8%AA%E6%95%B0%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F.png" alt="三个数比较大小"></p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">你身边的那位</span><br><span class="line">代替了我的座位</span><br><span class="line">他的手捧着玫瑰</span><br><span class="line">承诺余生都奉陪</span><br><span class="line">而我始终学不会</span><br><span class="line">已被风吹散的眼泪</span><br><span class="line">那逝去的幸福该怎么追回</span><br><span class="line">你身边的那位</span><br><span class="line">代替了我的称谓</span><br><span class="line">能懂你真心多贵</span><br><span class="line">不让你情绪破碎</span><br><span class="line">而我就应该后退</span><br><span class="line">藏进这回忆里昏睡</span><br><span class="line">往后的时光请你勇敢地飞</span><br><span class="line">勇敢地飞...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> logisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BUAA-CO」 序言</title>
      <link href="/2026/01/20/%E8%AE%A1%E7%BB%84%E5%BA%8F%E8%A8%80/"/>
      <url>/2026/01/20/%E8%AE%A1%E7%BB%84%E5%BA%8F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机组成原理，简称<code>CO</code>，是计算机学院在大二上学期开设的一门<code>5.5</code>学分的核心专业课，也是同学们来到计算机学院遇到的第一个拦路虎。课程分为理论和实验两部分，理论部分考察重点大致为以下几个知识点：<code>组合逻辑</code>，<code>时序逻辑</code>，<code>主存储器</code>，<code>cache</code>，<code>TLB</code>，<code>流水线CPU</code>，<code>mips代码补全</code>。实验部分也是CO最困难的部分，但他其实没有传说中的那么恐怖，唯一在干的事情就是设计CPU，从<code>logisim</code>到<code>verilog</code>，从单周期到流水线，只要诸位好好理解，相信征服CO并不是什么难事。<strong>实验最后的给分和实验截止时你所处在的Project有关</strong>，不出意外的话有三次gap机会，大家要好好珍惜哟。笔者接下来的系列Blog将围绕P0-P7展开，希望能对各位有所帮助。</p><h2 id="为什么写"><a href="#为什么写" class="headerlink" title="为什么写"></a>为什么写</h2><p>作为一个初入计算机学院懵懂的学生，笔者在初步上手的时候也遇到了很多困难：看不懂大佬学长的博客，听不懂老师上课讲的流水线设计思路，语法学习无从下手……这个时候的那种绝望可能大家只有经历了才知道。好在我遇到了热心友爱的同学，室友，如果没有他们的帮助，我不可能顺利通过CO。本着<strong>因为淋过雨，所以也想给学弟学妹撑把伞的热忱</strong>，我创作了系列Blog，该CO系列将尽可能使用通俗的语言来讲解晦涩的知识点，细节也会尽可能覆盖到，如果大佬阅读到该博客觉得写的太繁琐的话可以去看其他佬的作品，如果能阅读之后发现相关错误之处请及时联系我，笔者感激不尽🫡。</p><h2 id="CO学习方法的一些个人建议"><a href="#CO学习方法的一些个人建议" class="headerlink" title="CO学习方法的一些个人建议"></a>CO学习方法的一些个人建议</h2><ul><li>CO学习基本盘当然是在COpre阶段掌握好<code>verilog语法</code>（重中之重）</li><li>在设计过程中，如果你足够牛逼，那么自己设计是最好的；如果你喜欢看书，可以跟着书上的指示设计（没干过，但是舍友是这样的，大家可以尝试）;更推荐到方法是从<code>P3</code>开始跟着一个学长的<code>博客</code>和<code>github仓库</code>,沿着他的思路设计下去，在设计的过程中做出某些属于自己的优化和改动（千万别纯抄一遍下来），形成自己对流水线的理解。</li><li>在看博客时最好结合github的代码一起看，避免不必要的bug。</li><li>尽量在周中也完成一点工作，不要全压在周末，压力有点大的样子。</li><li>用好测评机，这是一个23级学长写的：<a href="https://github.com/Kie-Chi/COT%E3%80%82">https://github.com/Kie-Chi/COT。</a></li></ul><h2 id="不得不提的事情"><a href="#不得不提的事情" class="headerlink" title="不得不提的事情"></a>不得不提的事情</h2><p>大二上学期有两个比较重要的竞赛，当竞赛撞上闯关制的CO就会擦出不一样的火花，在这里给大家提个醒。</p><ul><li>12.5，<strong>全国部分地区大学生物理竞赛</strong>，这个只要你考前准备，做一点往年题，混个三等奖，你的物理就满分了，真的超值！！！但是可惜的他正好在周末撞上了CO的P5&#x2F;P6，所以这就体现了在周中推进计组实验的重要性，或者你可早点开始复习😁。</li><li>12.13，<strong>英语六级</strong>，有很大概率会撞上你的P7，大家有必要提前复习一下。</li></ul><p>如果你在暑假预习了计组并且碰到不会设计的问题并且无人可问，我的建议是跳过（别全跳过了哈），它不会对你开学正式的Project产生什么致命的影响。如果你在暑假<strong>没有</strong>预习计组，No Problem，开学还有时间，足够你翻盘。</p><p>个人感觉P0-P2比后面的P要难，在这几个Project你经常会被打信息差（很多别人会但是你不会的东西），其实他们都有相对固定的套路，就那么点东西，只要掌握了套路，你就可以在前3P轻车熟路了。可惜我是每次被打了信息差才学到的，痛苦了好久，悲！Let me tell you now😋。</p><h2 id="放心，别慌"><a href="#放心，别慌" class="headerlink" title="放心，别慌"></a>放心，别慌</h2><p>很多同学在刚开学的时候是对CO充满畏惧的，在这里跟大家说一下个人感觉。CO实验占比是40%，如果你全部做完的话和AK佬分数是不会差太多的，1-2分的样子。只要你理论不拉跨，应该分数在95分上下浮动。如果你出了点小意外卡在了P5，也别担心，不会挂科的，只要你好好准备理论考试，应该75到85问题不大。</p><p><strong>挂P不可怕，可怕的是就此丧失信心</strong>，认识一个哥们P3先挂三次展示容错，最后也顺利通关了。别怕，轻装上阵吧，加油！</p><p>你准备好了吗，让我们开启这段精彩的旅程吧。</p><p><strong>go go go !出发喽！……</strong></p><h2 id="Lyrics-Sharing"><a href="#Lyrics-Sharing" class="headerlink" title="Lyrics Sharing"></a>Lyrics Sharing</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">你的酒馆对我打了烊</span><br><span class="line">子弹在我心头上了膛</span><br><span class="line">请告诉我今后怎么扛</span><br><span class="line">遍体鳞伤</span><br><span class="line">还笑着原谅</span><br><span class="line">你的酒馆对我打了烊</span><br><span class="line">承诺是小孩子说的谎</span><br><span class="line">请告诉我今后怎么扛</span><br><span class="line">你无关痛痒</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/11/19/hello-world/"/>
      <url>/2025/11/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
